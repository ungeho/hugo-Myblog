+++
title = '浮動小数点数の基礎と誤差の仕組み'
date = 2025-12-07T19:03:04+09:00
draft = false
categories = ["Programming"]
tags = ["Float", "IEEE754", "数値計算", "誤差", "プログラミング"]
showtoc = true
tocopen = true
math = true
+++

プログラミング中に **「0.1 + 0.2 が 0.3 にならない」** といった、  
浮動小数点数特有の挙動に戸惑った経験はないでしょうか。  
これは、コンピューターが実数をそのまま正確に扱えないことに起因しています。  
  
本題に入る前に、もうひとつ直感に反する例を見てみましょう。

## (x - a) + a = x ?

数学的には、次の等式は常に成り立ちます。

$$
\begin{aligned}
(x - a) + a = x
\end{aligned}
$$

ところが、これをコンピューターで計算すると、この等式が**成り立たない場合**があります。  
以下の Python プログラムを実行すると、その様子を実際に確認できます。  
（ C など他の言語でも再現できますが、最適化により挙動が変わる場合があります。）  

```python
import math

def calc_a(x):
    n = math.log2(abs(x))
    return 2 ** (n + 53)

for x in range(1, 21):
    a = calc_a(x)
    # x - a
    temp = x - a
    # (x - a) + a
    result = temp + a
    # (x - a) + a の結果を表示
    print(f"({x:2d} - a) + a = {result:5.1f}",end="")
    # result != x なら  Not Equal! を表示
    print("\n" if result == x else "   Not Equal!\n", end="")
```

実行結果：

```bash
> py calc.py
( 1 - a) + a =   1.0
( 2 - a) + a =   2.0
( 3 - a) + a =   4.0   Not Equal!
( 4 - a) + a =   4.0
( 5 - a) + a =   8.0   Not Equal!
( 6 - a) + a =   8.0   Not Equal!
( 7 - a) + a =   8.0   Not Equal!
( 8 - a) + a =   8.0
( 9 - a) + a =  16.0   Not Equal!
(10 - a) + a =  16.0   Not Equal!
(11 - a) + a =  16.0   Not Equal!
(12 - a) + a =  16.0   Not Equal!
(13 - a) + a =  16.0   Not Equal!
(14 - a) + a =  16.0   Not Equal!
(15 - a) + a =  16.0   Not Equal!
(16 - a) + a =  16.0
(17 - a) + a =  32.0   Not Equal!
(18 - a) + a =  32.0   Not Equal!
(19 - a) + a =  32.0   Not Equal!
(20 - a) + a =  32.0   Not Equal!
```

多くのケースで$(x - a) + a \neq x$となっています。  
これは、**倍精度浮動小数点数が保持できる精度に限界があり、小さなxが大きなaとの差分計算で消えてしまうため**に起こる典型例です。  
よくある誤解として、**情報落ち**や**桁落ち**を「計算がおかしい」「演算が間違っている」と捉えてしまうことがあります。  
しかしこれは、**計算自体は仕様どおりに正しく行われており、その結果として情報が失われている** 状態です。  
> ここで起きている現象は**演算による丸め誤差ではありません。**
> 演算は正確に行われていますが、倍精度浮動小数点数の精度では小さなxを保持できず
> **表現の限界**によってxの情報が消えてしまう**情報落ち**が原因です。

---

この記事ではこのような現象の正体を理解するために

- **コンピューターが実数を正確に扱えない理由**  
- **IEEE754 に基づく浮動小数点数の仕組み**  
- **どのような数が誤差なく表現できるのか**  
- **decimal 型や固定小数点数ではどうなるのか**  
- **精度を保証する計算方法の一例としての「区間演算」**

について順に解説していきます。

## 計算機（コンピューター）の数値表現

### 全ての実数を正確に表現することはできない

数学における実数は、数直線上に存在するすべての数を指し、無限に長い桁を持つものや、極端に大きい値・小さい値も含まれています。  
しかし、コンピューターが演算や記憶に使える桁数には限りがあり、表現できる値の大きさにも制約があります。  

多くのプログラミング言語やアプリケーションでは、数値を表現する方法として IEEE 754 規格の **2 進数の倍精度浮動小数点数（double precision）** が採用されています。  

数学の世界では無限のリソースを仮定できますが、現実のコンピューターが使えるリソースは有限です。倍精度浮動小数点数は、実数を **正確に表す値ではなく、あくまで近似的に表すための値** として使用されます。

## IEEE 標準規格の浮動小数点数

IEEE 754 標準規格で定められている浮動小数点数（正規化数）は、次のように表されます。

$$
\begin{aligned}
a &= (-1)^{s} \times \left( 1 + \frac{d_{1}}{2^{1}} + \frac{d_{2}}{2^{2}} + \dots + \frac{d_{N-1}}{2^{N-1}} \right) \times 2^{e} \\\\
s &\in \{0,1\},\quad s\ \text{is a bit} \\\\
d_{i} &\in \{0,1\},\quad d_{i}\ \text{is a bit}
\end{aligned}
$$

### 符号部（Sign bit）

浮動小数点数で **正負の符号を表す 1 ビット分の領域** を **符号部** と呼びます。  
符号 $s$ が $0$ なら正（$+$）、$1$ なら負（$-$）を表します。

$$
(-1)^{s}
$$

---

### 仮数部（Mantissa / Significand）

浮動小数点数で **有効桁（精度）を担う部分** を **仮数部** と呼びます。  
仮数部は単精度では 23 ビット、倍精度では 52 ビットです。  

IEEE 754 では、正規化数については先頭ビットが必ず $1$ になることを利用して、その $1$ を格納しない **ケチ表現（hidden bit）** を用います。  
このため、正規化数であれば単精度は 24 ビット分、倍精度は 53 ビット分の精度を持ちます。

$$
\begin{aligned}
m &= \left( 1 + \frac{d_{1}}{2^{1}} + \frac{d_{2}}{2^{2}} + \dots + \frac{d_{N-1}}{2^{N-1}} \right) \\\\
d_{i} &\in \{0,1\},\quad d_{i}\ \text{is a bit}
\end{aligned}
$$

十進数で見ると、単精度は約 7 桁程度、倍精度はおよそ 15～16 桁程度の精度があります。

$$
\begin{aligned}
24\log_{10}(2) &\approx 7.22 \\\\
53\log_{10}(2) &\approx 15.95
\end{aligned}
$$

---

### 指数部（Exponent）

小数点の位置（2 進数での桁のシフト量）や数の大きさを表す部分を **指数部** と呼びます。  
指数部は一定のバイアス値を加えることで、負の数を含む指数を符号なし整数で表現する **バイアス付き整数** として格納されます。

$$
2^{e}
$$

指数部のビット列を $E$ としてバイアス値を $b$ とすると、実際の指数 $e$ は

$$
e = E - b
$$

で表されます。  
  
単精度および倍精度の指数部のビット数やバイアス値は次のようになります。


- **単精度（指数部 8 ビット）**  
  - **ビット列 $E$**  
    $$
    \begin{aligned}
    1 \le E \le 254
    \end{aligned}
    $$
  - **バイアス値 $b$**  
    $$
    \begin{aligned}
    b = 127
    \end{aligned}
    $$
  - **実際の指数 $e$**  
    $$
    \begin{aligned}
    -126 \le e \le 127
    \end{aligned}
    $$

- **倍精度（指数部 11 ビット）**  
  - **ビット列 $E$**  
    $$
    \begin{aligned}
    1 \le E \le 2046
    \end{aligned}
    $$
  - **バイアス値 $b$**  
    $$
    \begin{aligned}
    b = 1023
    \end{aligned}
    $$
  - **実際の指数 $e$**  
    $$
    \begin{aligned}
    -1022 \le e \le 1023
    \end{aligned}
    $$

---

また、特別な指数ビット列は次の用途に予約されています。

- **$E = 0$（指数ビット列がすべて $0$ のとき）**  
  - **仮数部のビット列もすべて 0、つまり $m = 0$ のとき**  
    $\pm 0$
  - **それ以外、つまり $m \neq 0$ のとき**  
    非正規化数

- **指数ビット列$E$がすべて 1 のとき（単精度なら $E = 255$、倍精度なら $E = 2047$）**  
  - **仮数部のビット列もすべて 0、つまり $m = 0$ のとき**  
    $\pm \infty$  
    計算結果が表現範囲を超えたときなどに現れる。このような現象を **オーバーフロー** と呼びます。
  - **それ以外、つまり $m \neq 0$ のとき**  
    NaN（非数）

---

### 精度による違い

浮動小数点数の精度には単精度（32 ビット）、倍精度（64 ビット）、任意精度など様々なものがあります。  
精度が高くなると仮数部のビット数が増えることで **扱える桁数（有効桁数）** が増え、指数部のビット数が増えることで **表現できる値の範囲** も広くなります。  

正規化数に対する仮数ビット $N$ と指数 $e$ の範囲は次のようになります。

$$
\begin{aligned}
\text{単精度}\quad N &= 24,\quad  -126 \le e \le 127 \\\\
\text{倍精度}\quad N &= 53,\quad  -1022 \le e \le 1023
\end{aligned}
$$

図にすると次のような感じになります。

- **単精度(32bit)**

```mermaid
flowchart LR
    S[Sign<br/>1 bit]:::small
    E[Exponent<br/>8 bits]:::mid
    M[Mantissa<br/>23 bits]:::large

    S --- E --- M

    classDef small fill:#fee,border:#f66;
    classDef mid fill:#eef,border:#66f;
    classDef large fill:#efe,border:#6f6;
```

- **倍精度(64bit)**

```mermaid
flowchart LR
    S[Sign<br/>1 bit]:::small
    E[Exponent<br/>11 bits]:::mid
    M[Mantissa<br/>52 bits]:::large

    S --- E --- M

    classDef small fill:#fee,border:#f66;
    classDef mid fill:#eef,border:#66f;
    classDef large fill:#efe,border:#6f6;
```

---

### なぜすべての実数を正確に表現できないのか

浮動小数点数を用いてすべての実数を正確に表現できない理由は、次の 3 点にまとめられます。

- **2 進数で小数を表現していること**  
    10 進数では有限桁で書ける数でも、2 進数にすると無限に続く小数になる場合が多くあります。  
    有名な例として**循環小数**になる **0.1** が挙げられます。

- **有効桁数（仮数部のビット数）が有限であること**  
    2 進小数が無限に続く場合でも、途中でどこかの桁で丸める必要があります。  
    この過程で**丸め誤差（rounding error）** が発生します。

- **扱える指数の範囲が有限であること**  
    指数部のビット数には限りがあるため、極端に大きい値・小さい値は表現できません。

---

### 浮動小数点数で正確に表現可能な例

仮数部の構造に注目すると、浮動小数点数で**正確に表せる値**は、実は非常に限られていることがわかります。  
次の数のうち、倍精度浮動小数点数で **誤差なく正確に表現できる数** はどれでしょうか？

$$
\begin{aligned}
0.1,\ 0.2,\ 0.3,\ 0.4,\ 0.5,\ 0.6,\ 0.7,\ 0.8,\ 0.9
\end{aligned}
$$

答えは **0.5 のみ** です。

$$
\begin{aligned}
0.5 = \frac{1}{2^1}
\end{aligned}
$$

理由は次の通りです。

浮動小数点数で正確に表現できる実数は、

$$
\begin{aligned}
\frac{M}{2^N}\\\\
M, N \in \mathbb{Z}
\end{aligned}
$$

の形で書けて、かつ **指数が指数部の範囲内に収まる必要があります**。  
  
つまり、次の **3 つすべてを満たす場合にのみ** 正確に表現できます。

- **2 進表現が有限で終わること（＝2^n で割った形に書けること）**  
- **分子が仮数部のビット数で表せる範囲の整数であること**  
- **指数が指数部の範囲内に収まること**

この条件を満たすのは、上の例では **0.5（1/2）** のみです。  
  
他にも、次のような値は2進小数が有限で終わり、仮数部と指数部の範囲に収まるため正確に表現できます。

$$
\begin{aligned}
3.625 &= 3 + \frac{1}{2^1} + \frac{1}{2^3} \\\\
      &= \frac{29}{2^3} \\\\
0.75  &= \frac{1}{2^1} + \frac{1}{2^2} \\\\
      &= \frac{3}{2^2}
\end{aligned}
$$

## 10進数の浮動小数点数なら誤差は発生しない？

10 進数の浮動小数点数（decimal 型）は、2 進数の倍精度浮動小数点数（double 型）と比べて「10 進で有限桁の小数を正確に表せる」という利点があります。  
たとえば **0.1** や **0.01** などは decimal 型では誤差なく表現できます。

しかし、次の問題は依然として残ります。

- **有効桁数（仮数部の桁数）が有限であること**  
- **扱える指数の範囲が有限であること**

そのため decimal 型でも、例えば

$$
\frac{1}{3} = 0.333333\dots
$$

のように **10 進でも無限に続く小数**を厳密に保持することはできません。

また、decimal 型は double 型に比べて **指数部の範囲が狭い**ため、  
表現できる値の最大値・最小値が小さくなり、  
「非常に大きな数値」「非常に小さな数値」を扱う用途には向きません。

つまり、decimal 型は

- **10進基準の計算を正確に行いたい**
- **ただし扱える数値レンジは狭くなる**

という特徴を持った形式です。

## 固定小数点数は？

固定小数点数（fixed-point）も、decimal 型と同様に **有効桁数が有限である** という問題を避けることはできません。  
そのため、表現できる値は刻み幅に依存しており、次の制約が存在します。

- **表せる小数の刻みが固定されている（例：0.01 刻みなど）**
- **その刻みで表せない値は丸めが発生する**
- **扱える範囲も有限である（オーバーフローの可能性）**

たとえば小数第2位までしか保持しない固定小数点形式では、

$$
0.123 \rightarrow 0.12
$$

のように必ず丸めが発生します。

固定小数点数は、演算が高速で予測可能という利点がある一方で、  
浮動小数点数のように **広い範囲の数を柔軟に扱うことはできません**。

## それでも厳密に正しい値を保持したい

浮動小数点数では誤差を完全に避けることはできませんが  
**計算結果が必ず真の値を含む範囲（区間）として得られる方法** があります。  
その一つが **区間演算（Interval Arithmetic）** です。

区間演算を用いることで、丸め誤差を含む計算でも、「真の値が必ずこの範囲にある」という **精度保証付きの計算(Verified numerics)** が可能になります。

## まとめ

- **コンピューターは有限のビット数しか持たないため、実数をそのまま格納することはできない**  
- **IEEE 754 浮動小数点数は「近似計算のための仕組み」であり、誤差は避けられない**  
- **正確に表せる値はごく限られた「2進で有限に表せる数」のみ**  
- **decimal 型や固定小数点数にも、精度や範囲の制限がある**  
- **「誤差を含んだまま安全に計算したい」という目的には区間演算が有効**

次の記事では、区間演算ライブラリを紹介します。
