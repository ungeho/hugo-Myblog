[{"content":" 💡 この記事は「浮動小数点数の基礎」シリーズの一部です。\n1. 浮動小数点数の基礎と誤差の仕組み\n2. 区間演算 👈 今ここ\n浮動小数点数で計算をしていると、「どこまでが正しい値なのか？」 という不安が常につきまといます。\n丸め誤差は1回の計算では小さくても、1,000回、1,000,000回と繰り返されるうちに無視できない大きさになっていきます。\n計算結果をひとつの値として扱う従来のアプローチでは、丸め誤差が累積してしまう問題があります。そこで役立つのが、区間演算(Interval Arithmetic) です。\n計算結果を「ひとつの値」ではなく、真値を必ず含む範囲（区間） として扱うことで、厳密に正しい値を計算します。\nこの記事では、区間演算の仕組みと、実際に利用できる区間演算ライブラリを紹介します。\n区間演算(Interval arithmetic) 区間演算とは、数値を1つの値ではなく「その値が存在しうる範囲（区間）」として扱う計算手法です。\n浮動小数点数では、丸め誤差によって計算結果が真の値からずれてしまう可能性があります。\n1回の演算では小さな誤差に感じるかもしませんが、丸め誤差が発生する演算を\n1,000回 10,000回 1,000,000回 と繰り返されると、丸め誤差が蓄積して無視できない大きさに達することがあります。\nそこで、実数$x$を1点で近似するのではなく\n機械的に表現できる浮動小数点数を端点にもつ閉区間\n$$ \\begin{aligned} X = [a,b] \\end{aligned} $$\nとして表現します。\nこれは「実数$x$は必ず$a$以上$b$以下のどこかにある」という形にすることで厳密に正しいものにしています。\n$$ \\begin{aligned} a \\le x \\le b \\end{aligned} $$\n丸め誤差を無視することなく、むしろ丸め誤差ごと包み込む形で表現するのが区間演算の特徴です。\n区間演算の種類 区間演算には大きく分けて上端下端型(inf-sup) と中心半径型(mid-rad) の2種類があります。\n1. 上端下端型(inf-sup 型 interval = [inf, sup]) 数値を「下端(inf)」と「上端(sup)」のペアで直接表現する方法です。\n$$ \\begin{aligned} X = [ inf , sup ] \\end{aligned} $$\n上端下端型の区間演算では\n下向き丸め\n下端を計算 上向き丸め\n上端を計算 のように計算します。\nこれにより、丸め誤差があっても必ず\u0026quot;真の値を含む区間\u0026quot;を保証できるのが最大の利点です。\n上端下端型(inf-sup)\n数値を[下端,上端]のペアで表現。\n下端を計算するときは下向き丸め、上端を計算するときは上向き丸めで計算することで、丸めの影響を把握して真の値を区間内に包含する。 中心半径型(mid-rad)\n数値を[中心点,半径]で表現\n$mid \\pm rad$のように区間を表現する。 2. 中心半径型(mid-rad 型 interval = [mid, rad]) 数値を「中心(mid)」と「半径(rad)」で表現します。\n$$ \\begin{aligned} X = mid \\pm rad \\end{aligned} $$\nつまり区間は\n$$ \\begin{aligned} X = [mid - rad , mid + rad] \\end{aligned} $$\nと解釈できます。\n区間演算による精度保証 浮動小数点数で計算していると\n「この結果は何桁目まで信じてよいのか？」\nという疑問が常につきまといます。\n通常の計算では、丸め誤差がどのように蓄積したのかを知ることができないため、結果のどこまでが正しい値なのかを判断できません。\nそこで役に立つのが区間演算(Interval Arithmetic) です。\n例として$\\pi$を区間で表現してみましょう。\n$$ \\begin{aligned} \\pi = [3.1415 , 3.1416] \\end{aligned} $$\nこれは次の意味を表します。\n$$ \\begin{aligned} 3.1415 \\le \\pi \\le 3.1416 \\end{aligned} $$\nここで、区間の両端で一致している桁を見ると\n$$ \\begin{aligned} {\\color{red}3.141}5 \\le \\pi \\le {\\color{red}3.141}6 \\end{aligned} $$\n赤文字の$3.141$の部分は左右で同じため、この4桁までは必ず正しい(精度が保証されている) ことがわかります。\n区間演算ライブラリの紹介 区間演算を実際に扱うためのライブラリは、上端下端型（inf-sup 型） と 中心半径型（mid-rad 型） に分かれています。\nそれぞれで代表的なライブラリを紹介します。\n上端下端型（Inf–Sup Interval） kv ライブラリ（C++）\nC++ で実装された精度保証付き数値計算ライブラリです。\n上端下端（inf–sup）で区間を扱うため、丸め方向を明示的に制御しながら区間を計算できます。\n使用には Boost が必要です。\n👉 kvライブラリ公式サイト 中心半径型（Mid–Rad Interval） Arb ライブラリ（C言語 / FLINT 統合）\nC/C++で使える高速な多倍長計算/中心半径型の区間演算ライブラリです。\n特殊関数の高精度計算にも用いられています。\n現在はFLINTに統合されたようです。\nLinux / macOS で動作します。\n👉 Arb Library Setup\nPython-FLINT（Python バインディング）\nArb / FLINT を Python から利用できる拡張モジュールです。\nWindows でも動作し、Python で高精度かつ精度保証付きの計算を行いたい場合に最適です。\n👉 Python-FLINT Setup\nPython-FLINTの導入(Windows) 現在の筆者の環境がwindowsな為、ここではPython FLINTの導入をしていきます。\n他のOSを使っている方はArbライブラリが統合されたFLINTやkvライブラリを導入すると良いです。\nモジュールのインストール\npy -m pip install python-flint 次のようにプログラムを作成\nfrom flint import arb x = arb.pi() print(x) 実行結果\n[3.14159265358979 +/- 3.34e-15] これは、次のような意味になっています。\n$$ \\begin{aligned} 3.14159265358979 \\pm (3.34 \\times 10^{-15}) \\end{aligned} $$\n範囲で表すと\n$$ \\begin{aligned} 3.14159265358979 - (3.34 \\times 10^{-15}) \\le \\pi \\le 3.14159265358979 + (3.34 \\times 10^{-15}) \\end{aligned} $$\nです。\n精度の変更 精度が保証された値をさらに高精度に求めるために、精度の変更を行っていきます。\n1. 精度をビット数(2進数)で指定する。\nプログラムを次のように変更します。\nビットで精度を指定したい時はctx.precを使用します。\nfrom flint import arb, ctx # 精度を106ビットに設定(10進で約32桁の精度) ctx.prec = 106 x = arb.pi() print(x) 106bitの精度は、10進数では次のように換算されます。\n$$ \\begin{aligned} 106\\times \\log_{10}(2) \\approx 31.9 \\end{aligned} $$\n実行結果\n[3.141592653589793238462643383279 +/- 5.06e-31] 2. 精度を10進数で指定する。\nプログラムを次のように変更します。\n10進数で精度を指定したいときはctx.dpsを使用します。\n10進で50桁程度の精度に設定します。\nfrom flint import arb, ctx # 10進でおよそ50桁分の精度 ctx.dps = 50 x = arb.pi() print(x) 実行結果\n[3.1415926535897932384626433832795028841971693993751 +/- 9.51e-51] 精度保証されている桁だけを出力する showgood関数を使うと、midのうちradiusの影響を受けない\n「区間の上下端が一致している桁(=good digits,精度保証値)」 だけを表示出来ます。\nArbの区間表示は\n[mid +/- rad] という形ですが、これは数学的には次の不等式を表しています。\n$$ \\begin{aligned} mid - rad \\le x \\le mid + rad \\end{aligned} $$\nここで\n上端 $$ \\begin{aligned} hi = mid + rad \\end{aligned} $$\n下端 $$ \\begin{aligned} lo = mid - rad \\end{aligned} $$\nとすると$hi$と$lo$を並べてみたときに、先頭から共通している桁は区間内のどんな真の値$x$を取っても変わらない桁になります。\nshowgoodはまさにこの\n上端$hi$と下端$lo$が一致している部分だけを抜き出した表示 つまり「精度が保証されている桁」だけを抜き出したmidの表現 を出力する関数です。\nプログラムを次のように変更します。\nfrom flint import arb, ctx, showgood # 計算精度を50桁に設定 ctx.dps = 50 x = arb.pi() print(\u0026#34;通常の出力:\u0026#34;) print(x) print(\u0026#34;showgoodによる出力:\u0026#34;) showgood(lambda: arb.pi()) # ctx.dps を指定していれば、dps=50は省略しても良い。 # showgood(lambda: arb.pi(), dps=50) 実行結果\n通常の出力: [3.1415926535897932384626433832795028841971693993751 +/- 9.51e-51] showgoodによる出力: 3.1415926535897932384626433832795028841971693993751 ※環境によっては\n3.1415926535897932384626433832795028841971693993751xxxx\nのように、不確かな桁がxでマスクされる形式で出力される場合もあります。\n実行例のようにshowgoodは、区間演算の結果から、確実に正しいとされる桁のみを表示する機能です。\nこの機能を使うことで、計算結果にどの程度の信頼性があるかを簡単に確認できます。\n他にも、Python-FLINTモジュールには様々な機能があります。\narbは実数の精度保証付きの数値計算に使用され、acbは虚数を含む計算を行いたい場合に使用します。虚数の精度保証付きの数値計算が必要な場合に、acbを使用することで、複素数計算を高精度に行えます。\nさらに詳しい使い方やAPIについては👉 Python-FLINT リファレンス をご覧ください。\nまとめ 本記事では区間演算（Interval Arithmetic） についての紹介と\n実際に使える区間演算ライブラリ(kv / Arb / Python-FLINT)を紹介しました。\n浮動小数点数は、本質的に\n有効桁が有限 計算量が増えるほど丸め誤差が蓄積する 扱える値の範囲が有限 といったような制約を持っています。\nそれに対し、区間演算は\n「真値が必ず含まれる範囲」を計算する 丸め誤差ごと安全に包み込む 結果のどこまでが信頼できるか(精度保証)が得られる という特徴を備えています。\nここで紹介したArb / Python-FLINTの中心半径型(mid-rad) は高速・高精度 であり\n数学計算・数値計算・誤差評価などで広く利用されています。\n✔️ 本記事のポイント\n区間演算では、丸め誤差を避けるために、計算結果を単一の値ではなく、誤差を含んだ範囲（区間）で表現することで、真値を必ず包含している区間を計算します。 区間演算には上端下端(inf-sup)型と中心半径(mid-rad)型の2種類の方法がある。 PythonではPython-FLINTが手軽で強力 showgoodを使うと保証された桁だけを取り出せる ✔️ 今後の記事では\u0026hellip;\n数値積分 数値微分 精度保証付きの自動微分 などを紹介します。\n","permalink":"http://localhost:1313/posts/interval/","summary":"\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e💡 \u003cstrong\u003eこの記事は「浮動小数点数の基礎」シリーズの一部です。\u003c/strong\u003e\u003cbr\u003e\n\u003ca href=\"../float\"\u003e\u003cstrong\u003e1. 浮動小数点数の基礎と誤差の仕組み\u003c/strong\u003e\u003c/a\u003e\u003cbr\u003e\n\u003ca href=\"../interval\"\u003e\u003cstrong\u003e2. 区間演算\u003c/strong\u003e\u003c/a\u003e \u003cstrong\u003e👈 今ここ\u003c/strong\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003cp\u003e浮動小数点数で計算をしていると、\u003cstrong\u003e「どこまでが正しい値なのか？」\u003c/strong\u003e という不安が常につきまといます。\u003c/p\u003e","title":"区間演算ライブラリの紹介"},{"content":" 💡 この記事は「浮動小数点数の基礎」シリーズの一部です。\n1. 浮動小数点数の基礎と誤差の仕組み 👈 今ここ\n2. 区間演算\nプログラミング中に 「0.1 + 0.2 が 0.3 にならない」 といった、浮動小数点数特有の挙動に戸惑った経験はないでしょうか。\nこれは、コンピューターが実数をそのまま正確に扱えないことに起因しています。\n本題に入る前に、もうひとつ直感に反する例を見てみましょう。\n(x - a) + a = x ? 数学的には、次の等式は常に成り立ちます。\n$$ \\begin{aligned} (x - a) + a = x \\end{aligned} $$\nところが、これをコンピューターで計算すると、この等式が成り立たない場合があります。\n以下の Python プログラムを実行すると、その様子を実際に確認できます。\n（ C など他の言語でも再現できますが、最適化により挙動が変わる場合があります。）\nimport math def calc_a(x): n = math.log2(abs(x)) return 2 ** (n + 53) for x in range(1, 21): a = calc_a(x) # x - a temp = x - a # (x - a) + a result = temp + a # (x - a) + a の結果を表示 print(f\u0026#34;({x:2d} - a) + a = {result:5.1f}\u0026#34;,end=\u0026#34;\u0026#34;) # result != x なら Not Equal! を表示 print(\u0026#34;\\n\u0026#34; if result == x else \u0026#34; Not Equal!\\n\u0026#34;, end=\u0026#34;\u0026#34;) 実行結果：\n\u0026gt; py calc.py ( 1 - a) + a = 1.0 ( 2 - a) + a = 2.0 ( 3 - a) + a = 4.0 Not Equal! ( 4 - a) + a = 4.0 ( 5 - a) + a = 8.0 Not Equal! ( 6 - a) + a = 8.0 Not Equal! ( 7 - a) + a = 8.0 Not Equal! ( 8 - a) + a = 8.0 ( 9 - a) + a = 16.0 Not Equal! (10 - a) + a = 16.0 Not Equal! (11 - a) + a = 16.0 Not Equal! (12 - a) + a = 16.0 Not Equal! (13 - a) + a = 16.0 Not Equal! (14 - a) + a = 16.0 Not Equal! (15 - a) + a = 16.0 Not Equal! (16 - a) + a = 16.0 (17 - a) + a = 32.0 Not Equal! (18 - a) + a = 32.0 Not Equal! (19 - a) + a = 32.0 Not Equal! (20 - a) + a = 32.0 Not Equal! 多くのケースで$(x - a) + a \\neq x$となっています。\n情報落ち 演算は正確に行われているが、変数 $x$ の情報が消えてしまう\nこの現象は、倍精度浮動小数点数が保持できる精度に限界があるために起こります。\n$(x - a)$の引き算を行う瞬間、有限の桁に巨大な数$a$とそれに対して小さな数$x$を同時に収めようとしています。\nしかし、枠の桁数が足りず、$x$の情報は欠落してしまいます。\nここで重要なのは、これは\n「計算がバグっている」 「演算途中でおかしな丸めが起きた」 といった種類の問題ではない、ということです。\n演算そのものは IEEE 754 の規定どおり正しく行われています。\nただし、倍精度浮動小数点数の 有効桁数は 53 ビットしかない ため、\n巨大な数 $a$ それに比べて十分小さい数 $x$ $(x - a)$ の引き算を行う瞬間、有限の桁数しかない器の中に、巨大な数 $a$ と、それに比べて十分小さい数 $x$ の両方を同時に収めよう としています。\nこのように、\n演算は仕様どおりに正しく行われている しかし「表現できる桁数が足りないせいで小さい項の情報が消える」 という現象を、ここでは 情報落ち と呼んでいます。\n桁落ち 似た現象として 桁落ち があります。\n情報落ち\n巨大な数 $\\pm$ 小さな数\n→ 大きな数と小さな数の両方を同じ枠（有効桁数）に収めることができず、\n小さいほうの項の情報が失われてしまう現象。\n桁落ち\n左辺 $a$ と右辺 $b$ がほぼ等しい（$a \\approx b$）とき、\n$a - b$ の引き算をすると有効桁数が極端に少なくなってしまう現象。\n桁落ちの場合は\n$$ \\begin{aligned} (a - b) \\times c \\end{aligned} $$\nのように後続の計算で誤差が大きく増幅されることがあります。\n特に、変数$c$が巨大な値だったとき、誤差が大きく増幅します。\n情報落ち・桁落ちの対策 情報落ちや桁落ちは 「演算そのもののミス」ではなく、演算を行う前の数値表現（ビットの限界）によって問題が生じる現象です。\nしかし、数学的に等価な別の計算方法を選ぶことで回避できる場合があります。\n情報落ちの対策\n計算順序を工夫する。\n情報落ちが起きやすいパターンとして、(「大きな値」+「中くらいの値」) + 「小さな値」のような計算順序になっていることがあります。\n「小さな値」＋「大きな値」という計算を避けるために、（「小さな値」＋「中くらいの値」）＋「大きな値」の順で計算することで、小さな値の情報が失われにくくなります。\n特に、加算をたくさん繰り返す処理では「これまでの合計」＋「次の項」という形になりがちで、「大きな値」＋「小さな値」の状態を作りやすいため注意が必要です。 桁落ちの対策\n数式を変形する。\nほぼ等しい値同士の引き算によって有効桁数が失われることが問題なので、差を直接計算することを避けるために式変形を行うことで対策することが可能です。 この記事ではこのような現象の正体を理解するために\nコンピューターが実数を正確に扱えない理由 IEEE754 に基づく浮動小数点数の仕組み どのような数が誤差なく表現できるのか decimal 型や固定小数点数ではどうなるのか 精度を保証する計算方法の一例としての「区間演算」 について順に解説していきます。\n計算機（コンピューター）の数値表現 全ての実数を正確に表現することはできない 数学における実数は、数直線上に存在するすべての数を指し、無限に長い桁を持つものや、極端に大きい値・小さい値も含まれています。\nしかし、コンピューターが演算や記憶に使える桁数には限りがあり、表現できる値の大きさにも制約があります。\n多くのプログラミング言語やアプリケーションでは、数値を表現する方法として IEEE 754 規格の 2 進数の倍精度浮動小数点数（double precision） が採用されています。\n数学の世界では無限のリソースを仮定できますが、現実のコンピューターが使えるリソースは有限です。倍精度浮動小数点数は、実数を 正確に表す値ではなく、あくまで近似的に表すための値 として使用されます。\nIEEE 標準規格の浮動小数点数 IEEE 754 標準規格で定められている浮動小数点数（正規化数）は、次のように表されます。\n$$ \\begin{aligned} a \u0026amp;= (-1)^{s} \\times \\left( 1 + \\frac{d_{1}}{2^{1}} + \\frac{d_{2}}{2^{2}} + \\dots + \\frac{d_{N-1}}{2^{N-1}} \\right) \\times 2^{e} \\\\ s \u0026amp;\\in {0,1},\\quad s\\ \\text{is a bit} \\\\ d_{i} \u0026amp;\\in {0,1},\\quad d_{i}\\ \\text{is a bit} \\end{aligned} $$\n符号部（Sign bit） 浮動小数点数で 正負の符号を表す 1 ビット分の領域 を 符号部 と呼びます。\n符号 $s$ が $0$ なら正（$+$）、$1$ なら負（$-$）を表します。\n$$ (-1)^{s} $$\n仮数部（Mantissa / Significand） 浮動小数点数で 有効桁（精度）を担う部分 を 仮数部 と呼びます。\n仮数部は単精度では 23 ビット、倍精度では 52 ビットです。\nIEEE 754 では、正規化数については先頭ビットが必ず $1$ になることを利用して、その $1$ を格納しない ケチ表現（hidden bit） を用います。\nこのため、正規化数であれば単精度は 24 ビット分、倍精度は 53 ビット分の精度を持ちます。\n$$ \\begin{aligned} m \u0026amp;= \\left( 1 + \\frac{d_{1}}{2^{1}} + \\frac{d_{2}}{2^{2}} + \\dots + \\frac{d_{N-1}}{2^{N-1}} \\right) \\\\ d_{i} \u0026amp;\\in {0,1},\\quad d_{i}\\ \\text{is a bit} \\end{aligned} $$\n十進数で見ると、単精度は約 7 桁程度、倍精度はおよそ 15～16 桁程度の精度があります。\n$$ \\begin{aligned} 24\\log_{10}(2) \u0026amp;\\approx 7.22 \\\\ 53\\log_{10}(2) \u0026amp;\\approx 15.95 \\end{aligned} $$\n指数部（Exponent） 小数点の位置（2 進数での桁のシフト量）や数の大きさを表す部分を 指数部 と呼びます。\n指数部は一定のバイアス値を加えることで、負の数を含む指数を符号なし整数で表現する バイアス付き整数 として格納されます。\n$$ 2^{e} $$\n指数部のビット列を $E$ としてバイアス値を $b$ とすると、実際の指数 $e$ は\n$$ e = E - b $$\nで表されます。\n単精度および倍精度の指数部のビット数やバイアス値は次のようになります。\n精度 指数部 $E$ $b$ $e = E - b$ 単精度 (32bit) 8bit $1 \\le E \\le 254$ $b=127$ $-126 \\le e \\le 127$ 倍精度 (64bit) 11bit $1 \\le E \\le 2046$ $b=1023$ $-1022 \\le e \\le 1023$ 特別な指数ビット列 また、特別な指数ビット列は次の用途に予約されています。\n指数部 仮数部 値の種類 説明 $E = 0$ $m = 0$ $\\pm 0$ 正負のゼロ $E = 0$ $m \\neq 0$ 非正規化数 絶対値が極端に小さい、0に非常に近い数を表す方法 $E_{max}$ $m = 0$ $\\pm \\infty$ 計算結果が表現可能な範囲を超えたときなどに現れる。この現象を オーバーフロー と呼ぶ $E_{max}$ $m \\neq 0$ NaN（非数） 0 で割るなど、数として解釈できない結果を表す 指数部$E=0$は指数ビット列がすべて0のときを指します。 指数部$E_{max}$は指数ビット列がすべて1のときを指します。\n単精度：$E = 255$\n倍精度：$E = 2047$ 精度による違い 浮動小数点数の精度には単精度（32 ビット）、倍精度（64 ビット）、任意精度など様々なものがあります。\n精度が高くなると仮数部のビット数が増えることで 扱える桁数（有効桁数） が増え、指数部のビット数が増えることで 表現できる値の範囲 も広くなります。\n正規化数に対する仮数ビット $N$ と指数 $e$ の範囲は次のようになります。\n$$ \\begin{aligned} \\text{単精度}\\quad N \u0026amp;= 24,\\quad -126 \\le e \\le 127 \\\\ \\text{倍精度}\\quad N \u0026amp;= 53,\\quad -1022 \\le e \\le 1023 \\end{aligned} $$\n図にすると次のような感じになります。\n単精度(32bit) flowchart LR\rS[Sign1 bit]:::small\rE[Exponent8 bits]:::mid\rM[Mantissa23 bits]:::large\rS --- E --- M\rclassDef small fill:#fee,border:#f66;\rclassDef mid fill:#eef,border:#66f;\rclassDef large fill:#efe,border:#6f6;\r倍精度(64bit) flowchart LR\rS[Sign1 bit]:::small\rE[Exponent11 bits]:::mid\rM[Mantissa52 bits]:::large\rS --- E --- M\rclassDef small fill:#fee,border:#f66;\rclassDef mid fill:#eef,border:#66f;\rclassDef large fill:#efe,border:#6f6;\rなぜすべての実数を正確に表現できないのか 浮動小数点数を用いてすべての実数を正確に表現できない理由は、次の 3 点にまとめられます。\n2 進数で小数を表現していること\n10 進数では有限桁で書ける数でも、2 進数にすると無限に続く小数になる場合が多くあります。\n有名な例として循環小数になる 0.1 が挙げられます。\n有効桁数（仮数部のビット数）が有限であること\n2 進小数が無限に続く場合でも、途中でどこかの桁で丸める必要があります。\nこの過程で丸め誤差（rounding error） が発生します。\n扱える指数の範囲が有限であること\n指数部のビット数には限りがあるため、極端に大きい値・小さい値は表現できません。\n浮動小数点数で正確に表現可能な例 仮数部の構造に注目すると、浮動小数点数で正確に表せる値は、実は非常に限られていることがわかります。\n次の数のうち、倍精度浮動小数点数で 誤差なく正確に表現できる数 はどれでしょうか？\n$$ \\begin{aligned} 0.1,\\ 0.2,\\ 0.3,\\ 0.4,\\ 0.5,\\ 0.6,\\ 0.7,\\ 0.8,\\ 0.9 \\end{aligned} $$\n答えは 0.5 のみ です。\n$$ \\begin{aligned} 0.5 = \\frac{1}{2^1} \\end{aligned} $$\n理由は次の通りです。\n浮動小数点数で正確に表現できる実数は、\n$$ \\begin{aligned} \u0026amp;\\frac{\\mu}{2^\\nu}\\\\ \\mu, \\nu \u0026amp;\\in \\mathbb{Z} \\end{aligned} $$\nの形で書けて、かつ 指数が指数部の範囲内に収まる必要があります。\nつまり、次の 3 つすべてを満たす場合にのみ 正確に表現できます。\n2 進表現が有限で終わること（$2^{\\nu}$ で割った形に書けること） 分子$\\mu$が仮数部のビット数で表せる範囲の整数であること 浮動小数点数の形に直した時に、指数が指数部の範囲内に収まること この条件を満たすのは、上の例では 0.5（1/2） のみです。\n他にも、次のような値は2進小数が有限で終わり、仮数部と指数部の範囲に収まるため正確に表現できます。\n$$ \\begin{aligned} \\qquad \\qquad 3.625 \u0026amp;= 2^1 + 2^0 + \\frac{1}{2^1} + \\frac{1}{2^3} \\\\ \u0026amp;= \\frac{29}{2^3} \\end{aligned} $$\n$$ \\begin{aligned} 0.75 \u0026amp;= \\frac{1}{2^1} + \\frac{1}{2^2} \\\\ \u0026amp;= \\frac{3}{2^2} \\end{aligned} $$\n$$ \\begin{aligned} 0.000000954606549 \u0026amp;= \\frac{1}{2^{20}} + \\frac{1}{2^{30}} + \\frac{1}{2^{40}} + \\frac{1}{2^{50}}\\\\ \u0026amp;= \\frac{1,074,791,425}{2^{50}} \\end{aligned} $$\n10進数の浮動小数点数なら誤差は発生しない？ 10 進数の浮動小数点数（decimal 型）は、2 進数の倍精度浮動小数点数（double 型）と比べて「10 進で有限桁の小数を正確に表せる」という利点があります。\nたとえば 0.1 や 0.01 などは decimal 型では誤差なく表現できます。\nしかし、次の問題は依然として残ります。\n有効桁数（仮数部の桁数）が有限であること 扱える指数の範囲が有限であること そのため decimal 型でも、例えば\n$$ \\frac{1}{3} = 0.333333\\dots $$\nのように 10 進でも無限に続く小数を厳密に保持することはできません。\nまた、decimal 型は double 型に比べて 指数部の範囲が狭いため、\n表現できる値の最大値・最小値が小さくなり、\n「非常に大きな数値」「非常に小さな数値」を扱う用途には向きません。\nつまり、decimal 型は\n10進基準の計算を正確に行いたい ただし扱える数値レンジは狭くなる という特徴を持った形式です。\n固定小数点数は？ 固定小数点数（fixed-point）も、decimal 型と同様に 有効桁数が有限である という問題を避けることはできません。\nそのため、表現できる値は刻み幅に依存しており、次の制約が存在します。\n表せる小数の刻みが固定されている（例：0.01 刻みなど） その刻みで表せない値は丸めが発生する 扱える範囲も有限である（オーバーフローの可能性） たとえば小数第2位までしか保持しない固定小数点形式では、\n$$ 0.123 \\rightarrow 0.12 $$\nのように必ず丸めが発生します。\n固定小数点数は、演算が高速で予測可能という利点がある一方で、\n浮動小数点数のように 広い範囲の数を柔軟に扱うことはできません。\nそれでも厳密に正しい値を保持したい 浮動小数点数では誤差を完全に避けることはできませんが\n計算結果が必ず真の値を含む範囲（区間）として得られる方法 があります。\nその一つが 区間演算（Interval Arithmetic） です。\n区間演算を用いることで、丸め誤差を含む計算でも、「真の値が必ずこの範囲にある」という 精度保証付きの計算(Verified numerics) が可能になります。\nまとめ コンピューターは有限のビット数しか持たないため、実数をそのまま格納することはできない IEEE 754 浮動小数点数は「近似計算のための仕組み」であり、誤差は避けられない 正確に表せる値はごく限られた「2進で有限に表せる数」のみ decimal 型や固定小数点数にも、精度や範囲の制限がある 「誤差を含んだまま安全に計算したい」という目的には区間演算が有効 次の記事では、区間演算ライブラリを紹介します。\n","permalink":"http://localhost:1313/posts/float/","summary":"\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e💡 \u003cstrong\u003eこの記事は「浮動小数点数の基礎」シリーズの一部です。\u003c/strong\u003e\u003cbr\u003e\n\u003ca href=\"../float\"\u003e\u003cstrong\u003e1. 浮動小数点数の基礎と誤差の仕組み\u003c/strong\u003e\u003c/a\u003e \u003cstrong\u003e👈 今ここ\u003c/strong\u003e\u003cbr\u003e\n\u003ca href=\"../interval\"\u003e\u003cstrong\u003e2. 区間演算\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003cp\u003eプログラミング中に \u003cstrong\u003e「0.1 + 0.2 が 0.3 にならない」\u003c/strong\u003e といった、浮動小数点数特有の挙動に戸惑った経験はないでしょうか。\u003cbr\u003e\nこれは、コンピューターが実数をそのまま正確に扱えないことに起因しています。\u003c/p\u003e","title":"浮動小数点数の基礎と誤差の仕組み"}]