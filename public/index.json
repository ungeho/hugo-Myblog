[{"content":" 💡 この記事は「コンピューターで計算する」シリーズの一部です。\n1. 浮動小数点数\n2. 区間演算\n3. 数値積分\n4. 数値微分 👈 今ここ\nコンピューターを用いた具体的な計算によって関数の傾きを求める手法を数値微分(numerical differentiation) と呼びます。\n微分の定義そのものは極限を用いて表されますが、コンピューター上では無限に小さい変化量を扱うことができません。\nそのため、有限の差分を用いて「微分を近似する」 方法が必要になります。\n数値微分 まず、微分は次のように定義されています。\n$$ \\begin{aligned} f^{\\prime}(x) = \\lim_{h \\to 0} \\frac{f(x + h) - f(x)}{h} \\end{aligned} $$\nしかし、実際の計算では$h$を無限に小さくすることはできません。\nそのため、有限の小さな$h$を用いて差分によって近似する必要があります。\n数値微分でよく用いられる差分近似として\n前進差分(Forward Difference) 後退差分(Backward Difference) 中心差分(Central Difference) があります。\nhの選び方 数値微分では\n$h$ が大きい $\\to$ 離散化誤差が大きい $h$ が小さすぎる $\\to$ 浮動小数点演算の丸めにより情報落ちが発生しやすい というトレードオフがあります。\nそこで、IEEE 754 の倍精度浮動小数点数の機械イプシロン $\\epsilon$ を用いると、 丸め誤差と離散化誤差のバランスをとる代表的なステップ幅の選び方として\n$$ \\begin{aligned} h = \\sqrt{\\epsilon}\\max(1, |x|) \\end{aligned} $$\nがよく用いられます。倍精度（仮数部 52 bit）の場合は\n$$ \\begin{aligned} \\epsilon = 2^{-52} \\end{aligned} $$\nとなります。\nこれは，$x+h$ や $x-h$ を計算したときに， 丸め誤差と離散化誤差の影響が釣り合うように選ばれたステップ幅であり， 数値微分において誤差を小さく抑えることを目的としています。\nさらに高精度の浮動小数点数を用いる場合には、その仮数部ビット数に応じて、$ x \\neq 0$のとき$\\epsilon = 2^{-52}$の$-52$の部分を調整すればよいです。\nまた、このときの$x = 0$のときの$h = 2^{-52}$ についても、任意で調整してください。\n前進差分(Forward Difference) $$ \\begin{aligned} f^{\\prime}(x) \u0026amp;\\approx \\frac{f(x + h) - f(x)}{h} \\\\ h \u0026amp;= \\sqrt{\\epsilon}\\max(1, |x|) \\end{aligned} $$\n前進差分の誤差は$O(h)$です。\n後退差分(Backward Difference) $$ \\begin{aligned} f^{\\prime}(x) \u0026amp;\\approx \\frac{f(x) - f(x - h)}{h} \\\\ h \u0026amp;= \\sqrt{\\epsilon}\\max(1, |x|) \\end{aligned} $$\n後退差分の誤差は$O(h)$です。\n中心差分(Central Difference) $$ \\begin{aligned} f^{\\prime}(x) \u0026amp;\\approx \\frac{f(x + h) - f(x - h)}{2h} \\\\ h \u0026amp;= \\sqrt{\\epsilon}\\max(1, |x|) \\end{aligned} $$\n中心差分の誤差は$O(h^{2})$であり、前進差分や後退差分より精度が高く、通常もっともよく利用される差分近似です。\n数値微分の実装例 ここでは、紹介した中でもっとも精度の良い中心差分を用いた数値微分の実装例を紹介します。\nimport math # 浮動小数点数の機械イプシロン # 浮動小数点数の精度を上げた場合はここを変更 EPS = 2.0**-52 # hの定義 def step_size(x: float) -\u0026gt; float: return math.sqrt(EPS) * max(1.0, abs(x)) # 数値微分f\u0026#39;(x) def diff(f, x: float) -\u0026gt; float: h = step_size(x) # 前進差分 # return ((f(x + h)) - f(x)) / h # 後退差分 # return (f(x) - f(x - h)) / h # 中心差分 return (f(x + h) - f(x - h)) / (2.0 * h) # f(x) の定義 def func(x) -\u0026gt; float: return x**2 + 3.0 x = 2.0 # f(x) と f\u0026#39;(x) の表示 print(f\u0026#34;f({x:5.2f}) = {func(x):10.6f}\u0026#34;) print(f\u0026#34;f\u0026#39;({x:5.2f}) = {diff(func, x):10.6f}\u0026#34;) 実行結果\nf( 2.00) = 7.000000 f\u0026#39;( 2.00) = 4.000000 まとめ 数値微分は、微分の定義に基づきながらも、コンピューターでは扱えない「極限」を有限差分で近似する手法です。\n特に中心差分は誤差が小さく、実用的な精度を得やすいためよく用いられます。\nまた、ステップ幅$h$は数値微分の精度を決める重要な要素であり、大きすぎても小さすぎても誤差が増えてしまいます。\nIEEE754の機械イプシロンを用いた\n$$ \\begin{aligned} h = \\sqrt{\\epsilon}\\max(1, |x|) \\end{aligned} $$\nという選び方は、丸め誤差と離散化誤差のバランスがよく、多くの応用で実用的です。\n実装例として中心差分をPythonで示しましたが、これは他の言語でも同様の考え方で使えます。\n数値微分は数値解法・最適化・微分方程式の計算など、多くの分野の基盤となる重要な技法です。\n","permalink":"http://localhost:1313/posts/numericaldifferentiation/","summary":"\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e💡 \u003cstrong\u003eこの記事は「コンピューターで計算する」シリーズの一部です。\u003c/strong\u003e\u003cbr\u003e\n\u003ca href=\"../float\"\u003e\u003cstrong\u003e1. 浮動小数点数\u003c/strong\u003e\u003c/a\u003e\u003cbr\u003e\n\u003ca href=\"../interval\"\u003e\u003cstrong\u003e2. 区間演算\u003c/strong\u003e\u003c/a\u003e\u003cbr\u003e\n\u003ca href=\"../numericalIntegration\"\u003e\u003cstrong\u003e3. 数値積分\u003c/strong\u003e\u003c/a\u003e\u003cbr\u003e\n\u003ca href=\"../numericalDifferentiation\"\u003e\u003cstrong\u003e4. 数値微分\u003c/strong\u003e\u003c/a\u003e \u003cstrong\u003e👈 今ここ\u003c/strong\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003cp\u003eコンピューターを用いた具体的な計算によって関数の傾きを求める手法を\u003cstrong\u003e数値微分(numerical differentiation)\u003c/strong\u003e と呼びます。\u003c/p\u003e","title":"数値微分"},{"content":" 💡 この記事は「コンピューターで計算する」シリーズの一部です。\n1. 浮動小数点数\n2. 区間演算\n3. 数値積分 👈 今ここ\n多くの積分は「紙とペン」で簡単に計算できるとは限りません。\n実際、積分の中には\n原始関数を初等関数で表せない といった理由で、解析的に解くことが難しいものが多数存在します。\nそのため、コンピューターを用いて積分を数値的に近似して求める手法(数値積分) が重要になります。\n数値積分では、関数の値を離散的に評価し、それらを小さな面積の総和として積み上げることで積分を近似します。\n数値積分(Numerical Integration) 与えられた関数の定積分の値を、解析的(紙とペンを使って式変形などを行う厳密な計算) ではなく、コンピューターを使って数値的に近似値を求める方法を数値積分(Numerical Integration) と呼びます。\n特に次のような場合に有効です\n解析的に積分できない関数を扱いたいとき 関数が複雑で厳密な解を求めるのが困難なとき 関数の式がなく、離散的なデータ点しか存在しないとき コンピューターは繰り返しの計算を高速かつ正確に行うことが得意です。\n積分区間を細かい区間に分割し、それぞれの部分の面積を求めて足し合わせる処理も素早く行うことができます。\n解析的に積分が出来ない例 解析的に積分することが困難な例として、次のような積分があります。\n$$ \\begin{aligned} \\int^{\\frac{\\pi}{2}}_{0} \\frac{d \\theta}{\\sqrt{1 - 0.5 \\sin^{2} \\theta }} \\end{aligned} $$\nこの積分の被積分関数は、初等関数で表現できる原始関数を持ちません。\nこのタイプの積分は数学的に特別な形をしており、実は楕円積分(Elliptic Integral) と呼ばれる「特殊関数」に分類されるものです。\nつまり、普通の関数(多項式・指数関数・三角関数など)をどれだけ組み合わせても、原始関数を表現することはできないため、解析的に解くことができません。\nそのため、値を求める方法の一つとして\n数値積分を用いて近似値を求める が用いられることがあります。\n解析的に積分できる関数は意外と限られており、現代では数値積分が極めて重要な役割を果たしています。\n数値積分法 この記事では次の数値積分法を紹介します。\n台形公式(Trapezoidal Rule) 二重指数関数型積分公式(DoubleExponentialFormula) 台形公式は最も基本的で理解しやすい数値積分法であり、多くの手法の基礎となります。\n一方、DE法(二重指数関数型積分公式)は、積分区間の端点に特異点(関数値が無限大に発散する点) を持つ関数に対しても高精度な結果を得られる強力な手法です。\nそれぞれの手法の特徴・利点について、わかりやすく解説していきます。\n台形公式(Trapezoidal Rule) 台形公式は、台形の面積を求める公式\n$$ \\begin{aligned} \\frac{(\\text{上底} + \\text{下底}) \\times \\text{高さ}}{2} \\end{aligned} $$\nに基づいて、定積分の値を台形の面積の和として近似する手法です。\n積分区間をいくつかの小さな区間に分割し、各区間で関数の値を「上底」と「下底」 、小区間の区間幅を「高さ」 とみなすことで、曲線のある面積を台形の集まりとして近似します。\n複合台形公式(Composite Trapezoidal Rule) 積分区間$[a,b]$を等間隔の小区間に分割し、その各区間に積分則を適用する方法を複合則と呼びます。\n特に、各小区間に台形公式を適用し、それらを足し合わせたものを複合台形公式(Composite Trapezoidal Rule) といいます。\n積分区間を$n$個の等間隔の小区間に分割し、各区間に台形公式を適用して得られる近似値を$T_{n}$とすると\n$$ \\begin{aligned} \\int_{a}^{b} f(x)dx \\approx T_{n} \\end{aligned} $$\nとなります。\n$T_{n}$の具体的な式 小区間(刻み幅)を\n$$ \\begin{aligned} h = \\frac{b - a}{ n } \\end{aligned} $$\nとすると、複合台形公式は次のように表されます。\n$$ \\begin{aligned} T_{n} \\approx h \\times ( \\frac{f(a)}{2} + \\sum_{i=1}^{n-1}f( a + hi ) + \\frac{f(b)}{2} ) \\end{aligned} $$\nここで\n$$ \\begin{aligned} \\frac{f(a)}{2} + \\sum_{i=1}^{n-1}f( a + hi ) + \\frac{f(b)}{2} \\end{aligned} $$\nは全ての台形の上底と下底の総和に対応し\n$$ \\begin{aligned} h \\end{aligned} $$\nは台形の高さに対応します。\n離散化(Discretization) このように、元々連続的な値で定義されている関数$f(x)$を\n$$ \\begin{aligned} f(a) \\quad,\\quad f(a + h) \\quad,\\quad f(a + 2h) \\quad,\\quad \\dots \\quad,\\quad f(b) \\end{aligned} $$\nという離散的な点によって近似的に扱うことを離散化(Discretization) と呼びます。\n台形公式の実装 次のPythonの例は、複合台形公式を用いて\n$$ \\begin{aligned} \\int_{0}^{1} x\\exp(x)dx = 1 \\end{aligned} $$\nの定積分を近似する方法を示したものです。\nimport numpy as np # 被積分関数 f(x) = x * exp(x) def f(x): return x * np.exp(x) # 複合台形公式 def trapezoidal_rule(f, a, b, n): h = (b - a) / n # aからbまでn+1個の等間隔の点を生成 x = np.linspace(a, b, n + 1) y = f(x) # y[0]とy[-1]は端点の関数値、f(a)とf(b) # [1:-1](a\u0026lt;b)の範囲の点での関数値の和を計算 approx = h * (0.5 * y[0] + y[1:-1].sum() + 0.5 * y[-1]) return approx def main(): a, b = 0.0, 1.0 # 積分区間 # 真値 (解析的に求めたときの値) true_value = 1.0 # 分割数nのリスト n_values = [2, 4, 8, 16, 32, 64, 128] print(\u0026#34;f(x) = x * exp(x) on [0, 1]\u0026#34;) print(\u0026#34;n\\t approx\\t\\t error\u0026#34;) print(\u0026#34;-\u0026#34; * 35) for n in n_values: approx = trapezoidal_rule(f, a, b, n) error = abs(true_value - approx) print(f\u0026#34;{n}\\t {approx:.10f}\\t {error:.2e}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() 実行結果\nf(x) = x * exp(x) on [0, 1] n approx error ----------------------------------- 2 1.0917507748 9.18e-02 4 1.0230644791 2.31e-02 8 1.0057741074 5.77e-03 16 1.0014440271 1.44e-03 32 1.0003610380 3.61e-04 64 1.0000902615 9.03e-05 128 1.0000225655 2.26e-05 分点数$n$を増やし刻み幅$h$を細かくするにつれて、台形公式の近似値が真値1に収束していく様子がよくわかります。\n数値積分では、一般に分点数を増やすことで精度を上げるというアプローチをとります。しかし、分割数を増やせばその分だけ計算回数も増加し、コンピューター上では丸め誤差が蓄積してしまいます。\nしたがって、単純に分割数を増やすだけでは限界があり、分点数を増やした時に高速に収束する高精度な積分法が求められます。\nその代表的な手法がDE公式(Double Exponential Formula, 二重指数関数型積分公式) です。\n二重指数関数型積分公式(Double Exponential Formula) 二重指数関数型積分公式(DE公式)は、台形公式をベースとしながらも、特別な変数変換を行うことで非常に高速な収束 を実現する積分法です。\n従来の数値積分法と比べ、次のような大きなメリットがあります。\n分点数を増やした際の収束が非常に速く、高精度な結果が得られる 被積分関数が積分区間の端点(無限に発散する点)を持っていても適用できる 無限区間や半無限区間の積分にも自然に拡張できる これらの特性により、DE公式は現代の数値積分手法の中でも特に強力で、科学技術計算や統計、計算物理など幅広い分野で用いられています。\nDE公式(Double Exponential Formula)の計算手順 DE公式は、積分区間の端点に特異性を持つ関数や、無限区間の積分を高精度で計算するための強力な手法です。\nその計算は次の2段階で行われます。\n元の積分に対して変数変換（DE変換）を行う\n変数変換 $x = \\phi(t)$ により、積分区間を $(-\\infty, \\infty)$ に写す。 もとの積分区間の端点にある特異性は、変数変換後には「無限遠点（非常に遠い位置）」へ押し出される。 変数変換後の積分に台形則を適用する\n変換後の被積分関数は、$|t|$ が大きくなるにつれて 二重指数的に減衰（急激に 0 に近づく） 。 このため、台形則による数値積分の収束が非常に速くなる。 変数変換によって積分は次の形になる\n$$ \\begin{aligned} \\int_{a}^{b} f(x)dx = \\int_{-\\infty}^{\\infty} f(\\phi(t))\\phi^{\\prime}(t) dt \\end{aligned} $$\nこの積分に台形則を適用すると\n$$ \\begin{aligned} \\int_{a}^{b} f(x)dx \u0026amp;\\approx h \\sum_{i=-n}^{n} f(\\phi(ih))\\phi^{\\prime}(ih)\\\\ h \u0026amp;= \\frac{\\log(3n)}{n} \\end{aligned} $$\n変換後の変数の高速な減衰によって極めて精度の高い数値積分 が得られます。\nDE変換 有限区間$[a,b]$ 積分区間が有限な区間$[a,b]$である場合は次のように変換します。\n$$ \\begin{aligned} \\int_{a}^{b} f(x)dx \u0026amp;= \\int_{-\\infty}^{\\infty} f(\\phi(t))\\phi^{\\prime}(t) dt\\\\ \\phi(t) \u0026amp;= \\frac{b - a}{2} \\tanh(\\frac{\\pi}{2}\\sinh(t)) + \\frac{a + b}{2}\\\\ \\phi^{\\prime}(t) \u0026amp;= \\frac{b - a}{4} \\frac{\\pi \\cosh(t)}{\\cosh^{2}(\\frac{\\pi}{2}\\sinh(t))} \\end{aligned} $$\n$\\phi(t)$ は\n$$ \\begin{aligned} \\phi(t) \\to a\\qquad \u0026amp;,\\qquad(t \\to -\\infty)\\\\ \\phi(t) \\to b\\qquad \u0026amp;,\\qquad(t \\to \\infty) \\end{aligned} $$\nのように、$ t \\to -\\infty $ で $a$、$ t \\to +\\infty $ で $b$ に近づきます。\nまた、被積分関数の積分区間の端点にある特異点を「無限遠へ押し出す」本当の理由は $\\phi^{\\prime}(t)$ にあります。\n$\\phi^{\\prime}(t)$ は $|t| \\to \\infty$ で二重指数的(かなり急激) に $0$ に減衰します。\nそのため、元々は積分区間の端点 $(a, b)$ に存在していた特異性は、変換後の積分では「無限遠に押し出され、積分にほとんど寄与しない」という扱いやすい形へ変換されます。\n桁落ちで結果がNaNになることがある この式は$t \\to -\\infty$で二重指数的(かなり急激)に $-1$へ近づいて、$t \\to \\infty$で二重指数的(かなり急激)に $1$へ近づいていきます。\n$$ \\begin{aligned} \\tanh(\\frac{\\pi}{2}\\sinh(t)) \\end{aligned} $$\nそのため\n$$ \\begin{aligned} \\tanh(u) \u0026amp;- 1\\\\ \\tanh(u) \u0026amp;+ 1 \\end{aligned} $$\nのような式が 浮動小数点の桁落ち を引き起こすことがあります。\n台形測のループの中でループの端点付近で桁落ちが発生したことで、結果がNaNになることもあります。\n桁落ちが発生した場合の対処法として、$\\tanh(\\frac{\\pi}{2}\\sinh(t))-1$または$\\tanh(\\frac{\\pi}{2}\\sinh(t))+1$のような形にならないように、式変形を行うことで対処することができます。\nまた、ここで使用されている特殊関数$\\sinh(x)$、$\\cosh(x)$、$\\tanh(x)$は双曲線関数(hyperbolic function) とよばれ、それぞれ次のように定義されています。\n$$ \\begin{aligned} \\sinh(x) \u0026amp;= \\frac{\\exp(x) - \\exp(-x)}{2}\\\\ \\cosh(x) \u0026amp;= \\frac{\\exp(x) + \\exp(-x)}{2}\\\\ \\tanh(x) \u0026amp;= \\frac{\\sinh(x)}{\\cosh(x)} = \\frac{\\exp(x) - \\exp(-x)}{\\exp(x) + \\exp(-x)} \\end{aligned} $$\n半無限区間$[a,\\infty)$ 積分区間が半無限区間$[a,\\infty)$である場合は次のように変換します。\n$$ \\begin{aligned} \\int_{a}^{\\infty} f(x)dx \u0026amp;= \\int_{-\\infty}^{\\infty} f(\\phi(t))\\phi^{\\prime}(t) dt\\\\ \\phi(t) \u0026amp;= a + \\exp(\\frac{\\pi}{2}\\sinh(t))\\\\ \\phi^{\\prime}(t) \u0026amp;= \\frac{\\pi}{2}\\cosh(t)\\exp(\\frac{\\pi}{2}\\sinh(t)) \\end{aligned} $$\n$\\phi(t)$ は\n$$ \\begin{aligned} \\phi(t) \\to a\\qquad \u0026amp;,\\qquad(t \\to -\\infty)\\\\ \\phi(t) \\to \\infty\\qquad \u0026amp;,\\qquad(t \\to \\infty) \\end{aligned} $$\nのように、$ t \\to -\\infty $ で $a$、$ t \\to +\\infty $ で $\\infty$ に近づきます。\n積分区間が$(\\infty,b]$の場合 $$ \\begin{aligned} \\int_{a}^{b} f(x)dx = -\\int_{b}^{a} f(x) dx \\end{aligned} $$\nを使います。つまり\n$$ \\begin{aligned} \\int_{-\\infty}^{b} f(x)dx = -\\int_{b}^{\\infty} f(x) dx \\end{aligned} $$\nとして公式を適用して計算を行います。\n変数変換前の被積分関数が指数的減衰を持つ場合 変数変換前の積分が既に指数的減衰特徴を持つ場合は次のように変換します。\n$$ \\begin{aligned} \\phi(t) = \\exp(t - \\exp( -t)) \\end{aligned} $$\n積分区間が$(-\\infty, \\infty)$の場合 積分区間が半無限区間$(-\\infty,\\infty)$である場合は次のように変換します。\n$$ \\begin{aligned} \\int_{-\\infty}^{\\infty} f(x)dx \u0026amp;= \\int_{-\\infty}^{\\infty} f(\\phi(t))\\phi^{\\prime}(t) dt\\\\ \\phi(t) \u0026amp;= \\sinh(\\frac{\\pi}{2}\\sinh(t))\\\\ \\phi^{\\prime}(t) \u0026amp;= \\frac{\\pi}{2}\\cosh(t)\\cosh(\\frac{\\pi}{2}\\sinh(t)) \\end{aligned} $$\n$\\phi(t)$ は\n$$ \\begin{aligned} \\phi(t) \\to \\infty\\qquad \u0026amp;,\\qquad(t \\to -\\infty)\\\\ \\phi(t) \\to \\infty\\qquad \u0026amp;,\\qquad(t \\to \\infty) \\end{aligned} $$\nのように、$ t \\to -\\infty $ で $-\\infty$、$ t \\to +\\infty $ で $\\infty$ に二重指数的に近づきます。\nDE公式の具体例 次の積分\n$$ \\begin{aligned} \\int_{0}^{1} \\frac{dx}{\\sqrt{x}} = 2 \\end{aligned} $$\nにDE公式を適用します。\nこの積分の真値は$2$であり、被積分関数$\\frac{1}{\\sqrt{x}}$は積分区間の端点$x=0$で特異性を持ちます。\nこの画像のように、$x$が$0$に近づくにつれて$f(x)$が発散していることがわかります。\n台形公式では、$x$が$0$に近づくにつれて$f(x)$が$\\infty$に発散することで、扱える範囲の値を超えてしまい、このような積分をうまく計算することができません。\nこの積分\n$$ \\begin{aligned} \\int_{0}^{1} f(x)dx \\end{aligned} $$\n$$ \\begin{aligned} f(x) = \\frac{1}{\\sqrt{x}} \\end{aligned} $$\nにDE変換を適用することで\n$$ \\begin{aligned} \\int_{-\\infty}^{\\infty} \u0026amp;g(t) dt\\\\ g(t) \u0026amp;= \\frac{\\phi^{\\prime}(t)}{\\sqrt{\\phi(t)}}\\\\ \\phi(t) \u0026amp;= \\frac{1}{2} (\\tanh(\\frac{\\pi}{2}\\sinh(t)) + 1)\\\\ \\phi^{\\prime}(t) \u0026amp;= \\frac{\\pi \\cosh(t)}{4 \\cosh^{2}(\\frac{\\pi}{2}\\sinh(t))} \\end{aligned} $$\nのような積分に変換されます。\nDE変換後のこの被積分関数をグラフにすると\nのように$|t| \\to \\infty$ で急激に0に近づく(二重指数的に減衰) していることがわかります。\nこれに、台形則を次のように適用します。\n$$ \\begin{aligned} h\\sum_{i=-n}^{n} g(ih) \\end{aligned} $$\n$$ \\begin{aligned} g(ih) = \\frac{\\pi \\cosh(ih)}{4 \\cosh^{2}(\\frac{\\pi}{2}\\sinh(ih))\\sqrt{\\frac{1}{2} (\\tanh(\\frac{\\pi}{2}\\sinh(ih)) + 1)}} \\end{aligned} $$\n$$ \\begin{aligned} h \u0026amp;= \\frac{\\log(3n)}{n} \\end{aligned} $$\nこのようにDE変換をした後に、台形則を適用して、分点数$n$を大きくしながら計算を行う様子をグラフにすると、次のようになります。\n上のアニメーションからわかるように、DE変換後に適用する台形則は、通常の台形則とまったく同じ動作をしているわけではありません。\n分点数 $n$ を増やすとき、台形則の分割が細かくなるだけでなく、数値積分を行う区間そのものが徐々に広がっています 。\nこれは、DE変換によって積分が\n$$ \\begin{aligned} \\int_{-\\infty}^{\\infty} g(t),dt \\end{aligned} $$\nという無限区間の積分に変換されているためで、実際の数値計算では\n$$ \\begin{aligned} t \\in [-nh,\\ nh] \\end{aligned} $$\nの有限区間を切り出して台形則を適用しています。\n分点数$n$が増えるとともにこの区間が外側へ広がるため、DE公式の収束には「刻み幅が小さくなる効果」(離散化誤差の減少)と「無限区間をより広く含める効果」(切り捨て誤差の減少)の両方が寄与しています。\nDE公式では、分点数$n$を増やすと 「刻み幅が小さくなる（離散化誤差が減る）」 と 「積分区間が広がる（切り捨て誤差が減る）」 の2つの効果が同時に進みます。\nこの2つの誤差は、DE変換後の被積分関数$g(t)$の二重指数的な減衰 によって、 常に同じくらいの大きさ に保たれるよう設計されています。\nその結果、誤差全体が $\\exp(-cn)$のように指数的に減衰し、通常の台形公式と比べて圧倒的に速い収束 が得られます。\nDE公式の実装例 次の積分をDE(Double Exponential)公式で計算します。\n$$ \\begin{aligned} \\int_{0}^{1} \\frac{dx}{\\sqrt{x}} = 2 \\end{aligned} $$\nこの積分の被積分関数\n$$ \\begin{aligned} f(x) = \\frac{1}{\\sqrt{x}} \\end{aligned} $$\nは、区間の端点$x=0$に特異性を持つため、通常の台形公式では正しく扱うことができません。\nDE公式では\n変数変換$x = \\phi(t)$により、端点の特異性を無限遠にとばす 二重指数的に減衰する関数に変換された後で台形測を適用 という流れで効率的に数値積分を行います。\n桁落ちを避けるための式変形 DE変換を適用してそのまま計算をすると\n$\\tanh(\u0026hellip;) - 1$のような危険な差による桁落ち 部分的に巨大な値が発生することでオーバーフロー などの原因によって、結果がNaNやInfになってしまうことがあります。\n今回の実装例はその典型例です。\nそこで、正負で場合分けしたロジスティック関数\n$$ \\begin{aligned} \\sigma(x) = \\frac{1}{1+e^{-x}} \\end{aligned} $$\nを用いて安全に計算しています。\npythonで実装すると次のようになります。\nimport numpy as np # ---- 被積分関数 f(x) = 1/sqrt(x) ---- def f(x): return 1.0 / np.sqrt(x) # ---- ロジスティック関数（符号で安定化） ---- def logistic(z): # σ(z) = 1 / (1 + exp(-z)) を桁落ち・オーバーフローしないように計算 out = np.empty_like(z) pos = z \u0026gt;= 0 neg = ~pos # z \u0026gt;= 0 のとき: exp(-z) は 0～1 に収まるので安全 out[pos] = 1.0 / (1.0 + np.exp(-z[pos])) # z \u0026lt; 0 のとき: exp(z) は 0～1 に収まるので安全 ez = np.exp(z[neg]) out[neg] = ez / (1.0 + ez) return out # ---- DE変換 φ(t) と φ\u0026#39;(t)（両方とも安定版） ---- def phi_and_phi_prime(t): # u = (π/2) sinh(t) u = (np.pi / 2.0) * np.sinh(t) z = 2.0 * u # = π sinh(t) s = logistic(z) # s = σ(z) = φ(t) phi = s # φ(t) 自体が σ(z) # φ\u0026#39;(t) = π cosh(t) * s * (1 - s) dphi = np.pi * np.cosh(t) * s * (1.0 - s) return phi, dphi # ---- DE公式で積分を計算 ---- def de_integrate(n): # 刻み幅 h = log(3n) / n h = np.log(3.0 * n) / n total = 0.0 for k in range(-n, n + 1): t = k * h x, dphi = phi_and_phi_prime(t) total += f(x) * dphi return h * total def main(): true_value = 2.0 n_values = [4, 8, 16, 32, 64, 128] print(\u0026#34;DE integration of ∫0^1 dx/√x (with underflow/cancellation-safe transform)\u0026#34;) print(\u0026#34; n approx error\u0026#34;) print(\u0026#34;-------------------------------------------\u0026#34;) for n in n_values: approx = de_integrate(n) error = abs(approx - true_value) print(f\u0026#34;{n:3d} {approx: .12f} {error:.3e}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() 実行結果\nn approx error ------------------------------------------- 4 2.000012041343 1.204e-05 8 2.000000004154 4.154e-09 16 2.000000000000 2.220e-15 32 2.000000000000 4.441e-16 64 2.000000000000 4.441e-16 128 2.000000000000 1.554e-15 台形公式とDE公式の特徴の比較 台形公式とDE公式の特徴を比較すると次のようになります。\n項目 台形公式 DE公式 誤差の減衰 $O(\\frac{1}{n^{2}})$ 多項式収束 $O(\\exp(-cn))$ 指数収束 無限区間の積分 ❌ 直接は不可（変換が必要） ✅DE変換で自然に処理できる 端点の特異点 計算不能（端点発散） 計算可能 実装の容易さ ◎ 非常に簡単 △ 変数変換・微分計算が必要 台形公式とDE公式の誤差の減衰を比較 次の定積分を、台形公式とDE公式で計算して誤差の減衰を比較します。\n$$ \\begin{aligned} \\int_{0}^{1} e^{x} dx = e - 1 \\end{aligned} $$\nTrapezoidal rule(台形公式)とDE rule(二重指数関数型積分公式)の誤差の減衰を対数グラフで比較しています。\n台形公式(青)\n分点数$n$を増やすと徐々に誤差が減衰していきますが、その減衰速度は速くありません。\n理論的には台形公式の誤差は $$ \\begin{aligned} O(\\frac{1}{n^{2}}) \\end{aligned} $$ の多項式的な収束を示し、実際グラフでもほぼ直線的に下がる緩やかな減衰 になっています。 DE公式(橙)\n小さな$n$でも誤差が急激に減衰し、$n=16$を超えたあたりで早くも$10^{-15}$(倍精度浮動小数点数が保持できる桁の限界付近) に達しています。\nこれはDE公式の誤差が $$ \\begin{aligned} O(\\exp(-cn)) \\end{aligned} $$ のような指数的収束 を示すためで、台形公式と比べて圧倒的に早く収束することがわかります。 全体の比較\n台形公式は分点数$n$を増やすほど少しずつ精度が上がるのに対し、DE公式は極めて少ない分点数で機械精度に達するほど高効率です。\n滑らかな関数$e^{x}$に対しても、DE公式が非常に高い性能を発揮することを示しています。 区間演算による精度保証について 台形公式やDE公式はいずれも数値的な近似手法であり積分値を厳密に求める際には、何らかの誤差が含まれます。\n台形公式では主に離散化誤差(刻み幅による誤差) DE公式では離散化誤差に加えて変数変換後の全無限の積分区間を有限区間で「打ち切る」ことによる打ち切り誤差 これらの誤差が理論的に存在します。\n精度保証付き数値計算(Verified Numerics) を実現するためには、これらすべての誤差要因を厳密に評価し、最終結果を区間として包含する必要があります。\nしかし、誤差項の理論的扱いは非常に高度であり、特にDE公式のように変数変換を伴う手法では、誤差の評価式そのものが複雑になります。\nそのため、ここでは詳細な理論展開には踏み込みません。\n精度保証付き数値計算を本格的に学びたい方のために、参考となる書籍のみ紹介することにします。\n📘精度保証付き数値計算の基礎\nまとめ この記事では、数値積分の基本である台形公式と積分区間の端点の特異点や無限区間の積分にも対応できる高精度な手法であるDE(Double Exponential)公式を紹介しました。\n台形公式はシンプルで実装しやすい反面、収束は多項式的で、特異点には弱い DE公式は変数変換によって積分区間の端点の特異点を無限遠点へ押し出し、指数的な収束を実現する非常に強力な手法 DE公式を実装する際には桁落ちやオーバーフローを避けるために式変形が必要なことがある 精度保証を行うには、離散化誤差・打切り誤差などの理論的な誤差を数学的に評価し、区間演算で包含する必要がある 現代の数値計算では「解析的に積分できない関数」のほうが一般的です。\nそのため、数値積分の基礎を理解し、適切な方法を選択できることは非常に重要です。\n台形公式のような基本的な手法だけでなく、DE公式のような高精度手法まで理解しておくと、実際の科学技術計算・統計計算・シミュレーションなどで大きな力になります。\n","permalink":"http://localhost:1313/posts/numericalintegration/","summary":"\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e💡 \u003cstrong\u003eこの記事は「コンピューターで計算する」シリーズの一部です。\u003c/strong\u003e\u003cbr\u003e\n\u003ca href=\"../float\"\u003e\u003cstrong\u003e1. 浮動小数点数\u003c/strong\u003e\u003c/a\u003e\u003cbr\u003e\n\u003ca href=\"../interval\"\u003e\u003cstrong\u003e2. 区間演算\u003c/strong\u003e\u003c/a\u003e\u003cbr\u003e\n\u003ca href=\"../numericalIntegration\"\u003e\u003cstrong\u003e3. 数値積分\u003c/strong\u003e\u003c/a\u003e \u003cstrong\u003e👈 今ここ\u003c/strong\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003cp\u003e多くの積分は「紙とペン」で簡単に計算できるとは限りません。\u003cbr\u003e\n実際、積分の中には\u003c/p\u003e","title":"数値積分"},{"content":" 💡 この記事は「コンピューターで計算する」シリーズの一部です。\n1. 浮動小数点数\n2. 区間演算👈 今ここ\n3. 数値積分\n浮動小数点数で計算をしていると、「どこまでが正しい値なのか？」 という不安が常につきまといます。\n丸め誤差は1回の計算では小さくても、1,000回、1,000,000回と繰り返されるうちに無視できない大きさになっていきます。\n計算結果をひとつの値として扱う従来のアプローチでは、丸め誤差が累積してしまう問題があります。そこで役立つのが、区間演算(Interval Arithmetic) です。\n計算結果を「ひとつの値」ではなく、真値を必ず含む範囲（区間） として扱うことで、厳密に正しい値を計算します。\nこの記事では、区間演算の仕組みと、実際に利用できる区間演算ライブラリを紹介します。\n区間演算(Interval arithmetic) 区間演算とは、数値を1つの値ではなく「その値が存在しうる範囲（区間）」として扱う計算手法です。\n浮動小数点数では、丸め誤差によって計算結果が真の値からずれてしまう可能性があります。\n1回の演算では小さな誤差に感じるかもしませんが、丸め誤差が発生する演算を\n1,000回 10,000回 1,000,000回 と繰り返されると、丸め誤差が蓄積して無視できない大きさに達することがあります。\nそこで、実数$x$を1点で近似するのではなく\n機械的に表現できる浮動小数点数を端点にもつ閉区間\n$$ \\begin{aligned} X = [a,b] \\end{aligned} $$\nとして表現します。\nこれは「実数$x$は必ず$a$以上$b$以下のどこかにある」という形にすることで厳密に正しいものにしています。\n$$ \\begin{aligned} a \\le x \\le b \\end{aligned} $$\n丸め誤差を無視することなく、むしろ丸め誤差ごと包み込む形で表現するのが区間演算の特徴です。\n区間演算の種類 区間演算には大きく分けて上端下端型(inf-sup) と中心半径型(mid-rad) の2種類があります。\n1. 上端下端型(inf-sup 型 interval = [inf, sup]) 数値を「下端(inf)」と「上端(sup)」のペアで直接表現する方法です。\n$$ \\begin{aligned} X = [ inf , sup ] \\end{aligned} $$\n上端下端型の区間演算では\n下向き丸め\n下端を計算 上向き丸め\n上端を計算 のように計算します。\nこれにより、丸め誤差があっても必ず\u0026quot;真の値を含む区間\u0026quot;を保証できるのが最大の利点です。\n上端下端型(inf-sup)\n数値を[下端,上端]のペアで表現。\n下端を計算するときは下向き丸め、上端を計算するときは上向き丸めで計算することで、丸めの影響を把握して真の値を区間内に包含する。 中心半径型(mid-rad)\n数値を[中心点,半径]で表現\n$mid \\pm rad$のように区間を表現する。 2. 中心半径型(mid-rad 型 interval = [mid, rad]) 数値を「中心(mid)」と「半径(rad)」で表現します。\n$$ \\begin{aligned} X = mid \\pm rad \\end{aligned} $$\nつまり区間は\n$$ \\begin{aligned} X = [mid - rad , mid + rad] \\end{aligned} $$\nと解釈できます。\n区間演算による精度保証 浮動小数点数で計算していると\n「この結果は何桁目まで信じてよいのか？」\nという疑問が常につきまといます。\n通常の計算では、丸め誤差がどのように蓄積したのかを知ることができないため、結果のどこまでが正しい値なのかを判断できません。\nそこで役に立つのが区間演算(Interval Arithmetic) です。\n例として$\\pi$を区間で表現してみましょう。\n$$ \\begin{aligned} \\pi = [3.1415 , 3.1416] \\end{aligned} $$\nこれは次の意味を表します。\n$$ \\begin{aligned} 3.1415 \\le \\pi \\le 3.1416 \\end{aligned} $$\nここで、区間の両端で一致している桁を見ると\n$$ \\begin{aligned} {\\color{red}3.141}5 \\le \\pi \\le {\\color{red}3.141}6 \\end{aligned} $$\n赤文字の${\\color{red}3.141}$の桁は区間の両端で同じ値であるため、この4桁までは必ず正しい(精度が保証されている) ことがわかります。\n区間演算ライブラリの紹介 区間演算を実際に扱うためのライブラリは、上端下端型（inf-sup 型） と 中心半径型（mid-rad 型） に分かれています。\nそれぞれで代表的なライブラリを紹介します。\n上端下端型（Inf–Sup Interval） kv ライブラリ（C++）\nC++ で実装された精度保証付き数値計算ライブラリです。\n上端下端（inf–sup）で区間を扱うため、丸め方向を明示的に制御しながら区間を計算できます。\n使用には Boost が必要です。\n👉 kvライブラリ公式サイト 中心半径型（Mid–Rad Interval） Arb ライブラリ（C言語 / FLINT 統合）\nC/C++で使える高速な多倍長計算/中心半径型の区間演算ライブラリです。\n特殊関数の高精度計算にも用いられています。\n現在はFLINTに統合されたようです。\nLinux / macOS で動作します。\n👉 Arb Library Setup\nPython-FLINT（Python バインディング）\nArb / FLINT を Python から利用できる拡張モジュールです。\nWindows でも動作し、Python で高精度かつ精度保証付きの計算を行いたい場合に最適です。\n👉 Python-FLINT Setup\nPython-FLINTの導入(Windows) 現在の筆者の環境がwindowsな為、ここではPython FLINTの導入をしていきます。\n他のOSを使っている方はArbライブラリが統合されたFLINTやkvライブラリを導入すると良いです。\nモジュールのインストール\npy -m pip install python-flint 次のようにプログラムを作成\nfrom flint import arb x = arb.pi() print(x) 実行結果\n[3.14159265358979 +/- 3.34e-15] これは、次のような意味になっています。\n$$ \\begin{aligned} 3.14159265358979 \\pm (3.34 \\times 10^{-15}) \\end{aligned} $$\n範囲で表すと\n$$ \\begin{aligned} 3.14159265358979 - (3.34 \\times 10^{-15}) \\le \\pi \\le 3.14159265358979 + (3.34 \\times 10^{-15}) \\end{aligned} $$\nです。\n精度の変更 精度が保証された値をさらに高精度に求めるために、精度の変更を行っていきます。\n1. 精度をビット数(2進数)で指定する。\nプログラムを次のように変更します。\nビットで精度を指定したい時はctx.precを使用します。\nfrom flint import arb, ctx # 精度を106ビットに設定(10進で約32桁の精度) ctx.prec = 106 x = arb.pi() print(x) 106bitの精度は、10進数では次のように換算されます。\n$$ \\begin{aligned} 106\\times \\log_{10}(2) \\approx 31.9 \\end{aligned} $$\n実行結果\n[3.141592653589793238462643383279 +/- 5.06e-31] 2. 精度を10進数で指定する。\nプログラムを次のように変更します。\n10進数で精度を指定したいときはctx.dpsを使用します。\n10進で50桁程度の精度に設定します。\nfrom flint import arb, ctx # 10進でおよそ50桁分の精度 ctx.dps = 50 x = arb.pi() print(x) 実行結果\n[3.1415926535897932384626433832795028841971693993751 +/- 9.51e-51] 精度保証されている桁だけを出力する showgood関数を使うと、midのうちradiusの影響を受けない\n「区間の上下端が一致している桁(=good digits,精度保証値)」 だけを表示出来ます。\nArbの区間表示は\n[mid +/- rad] という形ですが、これは数学的には次の不等式を表しています。\n$$ \\begin{aligned} mid - rad \\le x \\le mid + rad \\end{aligned} $$\nここで\n上端 $$ \\begin{aligned} hi = mid + rad \\end{aligned} $$\n下端 $$ \\begin{aligned} lo = mid - rad \\end{aligned} $$\nとすると$hi$と$lo$を並べてみたときに、先頭から共通している桁は区間内のどんな真の値$x$を取っても変わらない桁になります。\nshowgoodはまさにこの\n上端$hi$と下端$lo$が一致している部分だけを抜き出した表示 つまり「精度が保証されている桁」だけを抜き出したmidの表現 を出力する関数です。\nプログラムを次のように変更します。\nfrom flint import arb, ctx, showgood # 計算精度を50桁に設定 ctx.dps = 50 x = arb.pi() print(\u0026#34;通常の出力:\u0026#34;) print(x) print(\u0026#34;showgoodによる出力:\u0026#34;) showgood(lambda: arb.pi()) # ctx.dps を指定していれば、dps=50は省略しても良い。 # showgood(lambda: arb.pi(), dps=50) 実行結果\n通常の出力: [3.1415926535897932384626433832795028841971693993751 +/- 9.51e-51] showgoodによる出力: 3.1415926535897932384626433832795028841971693993751 ※環境によっては\n3.1415926535897932384626433832795028841971693993751xxxx\nのように、不確かな桁がxでマスクされる形式で出力される場合もあります。\n実行例のようにshowgoodは、区間演算の結果から、確実に正しいとされる桁のみを表示する機能です。\nこの機能を使うことで、計算結果にどの程度の信頼性があるかを簡単に確認できます。\n他にも、Python-FLINTモジュールには様々な機能があります。\narbは実数の精度保証付きの数値計算に使用され、acbは虚数を含む計算を行いたい場合に使用します。虚数の精度保証付きの数値計算が必要な場合に、acbを使用することで、複素数計算を高精度に行えます。\nさらに詳しい使い方やAPIについては👉 Python-FLINT リファレンス をご覧ください。\nまとめ 本記事では区間演算（Interval Arithmetic） についての紹介と\n実際に使える区間演算ライブラリ(kv / Arb / Python-FLINT)を紹介しました。\n浮動小数点数は、本質的に\n有効桁が有限 計算量が増えるほど丸め誤差が蓄積する 扱える値の範囲が有限 といったような制約を持っています。\nそれに対し、区間演算は\n「真値が必ず含まれる範囲」を計算する 丸め誤差ごと安全に包み込む 結果のどこまでが信頼できるか(精度保証)が得られる という特徴を備えています。\nここで紹介したArb / Python-FLINTの中心半径型(mid-rad) は高速・高精度 であり\n数学計算・数値計算・誤差評価などで広く利用されています。\n✔️ 本記事のポイント\n区間演算では、丸め誤差を避けるために、計算結果を単一の値ではなく、誤差を含んだ範囲（区間）で表現することで、真値を必ず包含している区間を計算します。 区間演算には上端下端(inf-sup)型と中心半径(mid-rad)型の2種類の方法がある。 PythonではPython-FLINTが手軽で強力 showgoodを使うと保証された桁だけを取り出せる ✔️ 今後の記事では\u0026hellip;\n数値積分 数値微分 精度保証付きの自動微分 などを紹介します。\n","permalink":"http://localhost:1313/posts/interval/","summary":"\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e💡 \u003cstrong\u003eこの記事は「コンピューターで計算する」シリーズの一部です。\u003c/strong\u003e\u003cbr\u003e\n\u003ca href=\"../float\"\u003e\u003cstrong\u003e1. 浮動小数点数\u003c/strong\u003e\u003c/a\u003e\u003cbr\u003e\n\u003ca href=\"../interval\"\u003e\u003cstrong\u003e2. 区間演算\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e👈 今ここ\u003c/strong\u003e\u003cbr\u003e\n\u003ca href=\"../numericalIntegration\"\u003e\u003cstrong\u003e3. 数値積分\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003cp\u003e浮動小数点数で計算をしていると、\u003cstrong\u003e「どこまでが正しい値なのか？」\u003c/strong\u003e という不安が常につきまといます。\u003c/p\u003e","title":"区間演算"},{"content":" 💡 この記事は「コンピューターで計算する」シリーズの一部です。\n1. 浮動小数点数👈 今ここ\n2. 区間演算\n3. 数値積分\nプログラミング中に 「0.1 + 0.2 が 0.3 にならない」 といった、浮動小数点数特有の挙動に戸惑った経験はないでしょうか。\nこれは、コンピューターが数を扱うときに広く使われている浮動小数点数が実数をそのまま正確に扱えないことに起因しています。\n本題に入る前に、もうひとつ直感に反する例を見てみましょう。\n(x - a) + a = x ? 数学的には、次の等式は常に成り立ちます。\n$$ \\begin{aligned} (x - a) + a = x \\end{aligned} $$\nところが、これをコンピューターで計算すると、この等式が成り立たない場合があります。\n以下の Python プログラムを実行すると、その様子を実際に確認できます。\n（ C など他の言語でも再現できますが、最適化により挙動が変わる場合があります。）\nimport math def calc_a(x): n = math.log2(abs(x)) return 2 ** (n + 53) for x in range(1, 21): a = calc_a(x) # x - a temp = x - a # (x - a) + a result = temp + a # (x - a) + a の結果を表示 print(f\u0026#34;({x:2d} - a) + a = {result:5.1f}\u0026#34;,end=\u0026#34;\u0026#34;) # result != x なら Not Equal! を表示 print(\u0026#34;\\n\u0026#34; if result == x else \u0026#34; Not Equal!\\n\u0026#34;, end=\u0026#34;\u0026#34;) 実行結果：\n\u0026gt; py calc.py ( 1 - a) + a = 1.0 ( 2 - a) + a = 2.0 ( 3 - a) + a = 4.0 Not Equal! ( 4 - a) + a = 4.0 ( 5 - a) + a = 8.0 Not Equal! ( 6 - a) + a = 8.0 Not Equal! ( 7 - a) + a = 8.0 Not Equal! ( 8 - a) + a = 8.0 ( 9 - a) + a = 16.0 Not Equal! (10 - a) + a = 16.0 Not Equal! (11 - a) + a = 16.0 Not Equal! (12 - a) + a = 16.0 Not Equal! (13 - a) + a = 16.0 Not Equal! (14 - a) + a = 16.0 Not Equal! (15 - a) + a = 16.0 Not Equal! (16 - a) + a = 16.0 (17 - a) + a = 32.0 Not Equal! (18 - a) + a = 32.0 Not Equal! (19 - a) + a = 32.0 Not Equal! (20 - a) + a = 32.0 Not Equal! 多くのケースで$(x - a) + a \\neq x$となっています。\n情報落ち 演算は正確に行われているが、変数 $x$ の情報が消えてしまう\nこの現象は、倍精度浮動小数点数が保持できる精度に限界があるために起こります。\n$(x - a)$の引き算を行う瞬間、有限の桁に巨大な数$a$とそれに対して小さな数$x$を同時に収めようとしています。\nしかし、枠の桁数が足りず、$x$の情報は欠落してしまいます。\nここで重要なのは、これは\n「計算がバグっている」 「演算途中でおかしな丸めが起きた」 といった種類の問題ではない、ということです。\n演算そのものは IEEE 754 の規定どおり正しく行われています。\nただし、倍精度浮動小数点数の 有効桁数は 53 ビットしかない ため、\n巨大な数 $a$ それに比べて十分小さい数 $x$ $(x - a)$ の引き算を行う瞬間、有限の桁数しかない器の中に、巨大な数 $a$ と、それに比べて十分小さい数 $x$ の両方を同時に収めよう としています。\nこのように、\n演算は仕様どおりに正しく行われている しかし「表現できる桁数が足りないせいで小さい項の情報が消える」 という現象を、ここでは 情報落ち と呼んでいます。\n桁落ち 似た現象として 桁落ち があります。\n情報落ち\n巨大な数 $\\pm$ 小さな数\n→ 大きな数と小さな数の両方を同じ枠（有効桁数）に収めることができず、\n小さいほうの項の情報が失われてしまう現象。\n桁落ち\n左辺 $a$ と右辺 $b$ がほぼ等しい（$a \\approx b$）とき、\n$a - b$ の引き算をすると有効桁数が極端に少なくなってしまう現象。\n桁落ちの場合は\n$$ \\begin{aligned} (a - b) \\times c \\end{aligned} $$\nのように後続の計算で誤差が大きく増幅されることがあります。\n特に、変数$c$が巨大な値だったとき、誤差が大きく増幅します。\n情報落ち・桁落ちの対策 情報落ちや桁落ちは 「演算そのもののミス」ではなく、演算を行う前の数値表現（ビットの限界）によって問題が生じる現象です。\nしかし、数学的に等価な別の計算方法を選ぶことで回避できる場合があります。\n情報落ちの対策\n計算順序を工夫する。\n情報落ちが起きやすいパターンとして、(「大きな値」+「中くらいの値」) + 「小さな値」のような計算順序になっていることがあります。\n「小さな値」＋「大きな値」という計算を避けるために、（「小さな値」＋「中くらいの値」）＋「大きな値」の順で計算することで、小さな値の情報が失われにくくなります。\n特に、加算をたくさん繰り返す処理では「これまでの合計」＋「次の項」という形になりがちで、「大きな値」＋「小さな値」の状態を作りやすいため注意が必要です。 桁落ちの対策\n数式を変形する。\nほぼ等しい値同士の引き算によって有効桁数が失われることが問題なので、差を直接計算することを避けるために式変形を行うことで対策することが可能です。 この記事ではこのような現象の正体を理解するために\nコンピューターが実数を正確に扱えない理由 IEEE754 に基づく浮動小数点数の仕組み どのような数が誤差なく表現できるのか decimal 型や固定小数点数ではどうなるのか 精度を保証する計算方法の一例としての「区間演算」 について順に解説していきます。\n計算機（コンピューター）の数値表現 全ての実数を正確に表現することはできない 数学における実数は、数直線上に存在するすべての数を指し、無限に長い桁を持つものや、極端に大きい値・小さい値も含まれています。\nしかし、コンピューターが演算や記憶に使える桁数には限りがあり、表現できる値の大きさにも制約があります。\n多くのプログラミング言語やアプリケーションでは、数値を表現する方法として IEEE 754 規格の 2 進数の倍精度浮動小数点数（double precision） が採用されています。\n数学の世界では無限のリソースを仮定できますが、現実のコンピューターが使えるリソースは有限です。倍精度浮動小数点数は、実数を 正確に表す値ではなく、あくまで近似的に表すための値 として使用されます。\nIEEE 標準規格の浮動小数点数 IEEE 754 標準規格で定められている浮動小数点数（正規化数）は、次のように表されます。\n$$ \\begin{aligned} a \u0026amp;= (-1)^{s} \\times \\left( 1 + \\frac{d_{1}}{2^{1}} + \\frac{d_{2}}{2^{2}} + \\dots + \\frac{d_{N-1}}{2^{N-1}} \\right) \\times 2^{e} \\\\ s \u0026amp;\\in {0,1},\\quad s\\ \\text{is a bit} \\\\ d_{i} \u0026amp;\\in {0,1},\\quad d_{i}\\ \\text{is a bit} \\end{aligned} $$\n符号部（Sign bit） 浮動小数点数で 正負の符号を表す 1 ビット分の領域 を 符号部 と呼びます。\n符号 $s$ が $0$ なら正（$+$）、$1$ なら負（$-$）を表します。\n$$ (-1)^{s} $$\n仮数部（Mantissa / Significand） 浮動小数点数で 有効桁（精度）を担う部分 を 仮数部 と呼びます。\n仮数部は単精度では 23 ビット、倍精度では 52 ビットです。\nIEEE 754 では、正規化数については先頭ビットが必ず $1$ になることを利用して、その $1$ を格納しない ケチ表現（hidden bit） を用います。\nこのため、正規化数であれば単精度は 24 ビット分、倍精度は 53 ビット分の精度を持ちます。\n$$ \\begin{aligned} m \u0026amp;= \\left( 1 + \\frac{d_{1}}{2^{1}} + \\frac{d_{2}}{2^{2}} + \\dots + \\frac{d_{N-1}}{2^{N-1}} \\right) \\\\ d_{i} \u0026amp;\\in {0,1},\\quad d_{i}\\ \\text{is a bit} \\end{aligned} $$\n十進数で見ると、単精度は約 7 桁程度、倍精度はおよそ 15～16 桁程度の精度があります。\n$$ \\begin{aligned} 24\\log_{10}(2) \u0026amp;\\approx 7.22 \\\\ 53\\log_{10}(2) \u0026amp;\\approx 15.95 \\end{aligned} $$\n指数部（Exponent） 小数点の位置（2 進数での桁のシフト量）や数の大きさを表す部分を 指数部 と呼びます。\n指数部は一定のバイアス値を加えることで、負の数を含む指数を符号なし整数で表現する バイアス付き整数 として格納されます。\n$$ 2^{e} $$\n指数部のビット列を $E$ としてバイアス値を $b$ とすると、実際の指数 $e$ は\n$$ e = E - b $$\nで表されます。\n単精度および倍精度の指数部のビット数やバイアス値は次のようになります。\n精度 指数部 $E$ $b$ $e = E - b$ 単精度 (32bit) 8bit $1 \\le E \\le 254$ $b=127$ $-126 \\le e \\le 127$ 倍精度 (64bit) 11bit $1 \\le E \\le 2046$ $b=1023$ $-1022 \\le e \\le 1023$ 特別な指数ビット列 また、特別な指数ビット列は次の用途に予約されています。\n指数部 仮数部 値の種類 説明 $E = 0$ $m = 0$ $\\pm 0$ 正負のゼロ $E = 0$ $m \\neq 0$ 非正規化数 絶対値が極端に小さい、0に非常に近い数を表す方法 $E_{max}$ $m = 0$ $\\pm \\infty$ 計算結果が表現可能な範囲を超えたときなどに現れる。この現象を オーバーフロー と呼ぶ $E_{max}$ $m \\neq 0$ NaN（非数） 0 で割るなど、数として解釈できない結果を表す 指数部$E=0$は指数ビット列がすべて0のときを指します。 指数部$E_{max}$は指数ビット列がすべて1のときを指します。\n単精度：$E = 255$\n倍精度：$E = 2047$ 精度による違い 浮動小数点数の精度には単精度（32 ビット）、倍精度（64 ビット）、任意精度など様々なものがあります。\n精度が高くなると仮数部のビット数が増えることで 扱える桁数（有効桁数） が増え、指数部のビット数が増えることで 表現できる値の範囲 も広くなります。\n正規化数に対する仮数ビット $N$ と指数 $e$ の範囲は次のようになります。\n$$ \\begin{aligned} \\text{単精度}\\quad N \u0026amp;= 24,\\quad -126 \\le e \\le 127 \\\\ \\text{倍精度}\\quad N \u0026amp;= 53,\\quad -1022 \\le e \\le 1023 \\end{aligned} $$\n図にすると次のような感じになります。\n単精度(32bit) flowchart LR\rS[Sign1 bit]:::small\rE[Exponent8 bits]:::mid\rM[Mantissa23 bits]:::large\rS --- E --- M\rclassDef small fill:#fee,border:#f66;\rclassDef mid fill:#eef,border:#66f;\rclassDef large fill:#efe,border:#6f6;\r倍精度(64bit) flowchart LR\rS[Sign1 bit]:::small\rE[Exponent11 bits]:::mid\rM[Mantissa52 bits]:::large\rS --- E --- M\rclassDef small fill:#fee,border:#f66;\rclassDef mid fill:#eef,border:#66f;\rclassDef large fill:#efe,border:#6f6;\rなぜすべての実数を正確に表現できないのか 浮動小数点数を用いてすべての実数を正確に表現できない理由は、次の 3 点にまとめられます。\n2 進数で小数を表現していること\n10 進数では有限桁で書ける数でも、2 進数にすると無限に続く小数になる場合が多くあります。\n有名な例として循環小数になる 0.1 が挙げられます。\n有効桁数（仮数部のビット数）が有限であること\n2 進小数が無限に続く場合でも、途中でどこかの桁で丸める必要があります。\nこの過程で丸め誤差（rounding error） が発生します。\n扱える指数の範囲が有限であること\n指数部のビット数には限りがあるため、極端に大きい値・小さい値は表現できません。\n浮動小数点数で正確に表現可能な例 仮数部の構造に注目すると、浮動小数点数で正確に表せる値は、実は非常に限られていることがわかります。\n次の数のうち、倍精度浮動小数点数で 誤差なく正確に表現できる数 はどれでしょうか？\n$$ \\begin{aligned} 0.1,\\ 0.2,\\ 0.3,\\ 0.4,\\ 0.5,\\ 0.6,\\ 0.7,\\ 0.8,\\ 0.9 \\end{aligned} $$\n答えは 0.5 のみ です。\n$$ \\begin{aligned} 0.5 = \\frac{1}{2^1} \\end{aligned} $$\n理由は次の通りです。\n浮動小数点数で正確に表現できる実数は、\n$$ \\begin{aligned} \u0026amp;\\frac{\\mu}{2^\\nu}\\\\ \\mu, \\nu \u0026amp;\\in \\mathbb{Z} \\end{aligned} $$\nの形で書けて、かつ 指数が指数部の範囲内に収まる必要があります。\nつまり、次の 3 つすべてを満たす場合にのみ 正確に表現できます。\n2 進表現が有限で終わること（$2^{\\nu}$ で割った形に書けること） 分子$\\mu$が仮数部のビット数で表せる範囲の整数であること 浮動小数点数の形に直した時に、指数が指数部の範囲内に収まること この条件を満たすのは、上の例では 0.5（1/2） のみです。\n他にも、次のような値は2進小数が有限で終わり、仮数部と指数部の範囲に収まるため正確に表現できます。\n$$ \\begin{aligned} \\qquad \\qquad 3.625 \u0026amp;= 2^1 + 2^0 + \\frac{1}{2^1} + \\frac{1}{2^3} \\\\ \u0026amp;= \\frac{29}{2^3} \\end{aligned} $$\n$$ \\begin{aligned} 0.75 \u0026amp;= \\frac{1}{2^1} + \\frac{1}{2^2} \\\\ \u0026amp;= \\frac{3}{2^2} \\end{aligned} $$\n$$ \\begin{aligned} 0.000000954606549 \u0026amp;= \\frac{1}{2^{20}} + \\frac{1}{2^{30}} + \\frac{1}{2^{40}} + \\frac{1}{2^{50}}\\\\ \u0026amp;= \\frac{1,074,791,425}{2^{50}} \\end{aligned} $$\n10進数の浮動小数点数なら誤差は発生しない？ 10 進数の浮動小数点数（decimal 型）は、2 進数の倍精度浮動小数点数（double 型）と比べて「10 進で有限桁の小数を正確に表せる」という利点があります。\nたとえば 0.1 や 0.01 などは decimal 型では誤差なく表現できます。\nしかし、次の問題は依然として残ります。\n有効桁数（仮数部の桁数）が有限であること 扱える指数の範囲が有限であること そのため decimal 型でも、例えば\n$$ \\frac{1}{3} = 0.333333\\dots $$\nのように 10 進でも無限に続く小数を厳密に保持することはできません。\nまた、decimal 型は double 型に比べて 指数部の範囲が狭いため、\n表現できる値の最大値・最小値が小さくなり、\n「非常に大きな数値」「非常に小さな数値」を扱う用途には向きません。\nつまり、decimal 型は\n10進基準の計算を正確に行いたい ただし扱える数値レンジは狭くなる という特徴を持った形式です。\n固定小数点数は？ 固定小数点数（fixed-point）も、decimal 型と同様に 有効桁数が有限である という問題を避けることはできません。\nそのため、表現できる値は刻み幅に依存しており、次の制約が存在します。\n表せる小数の刻みが固定されている（例：0.01 刻みなど） その刻みで表せない値は丸めが発生する 扱える範囲も有限である（オーバーフローの可能性） たとえば小数第2位までしか保持しない固定小数点形式では、\n$$ 0.123 \\rightarrow 0.12 $$\nのように必ず丸めが発生します。\n固定小数点数は、演算が高速で予測可能という利点がある一方で、\n浮動小数点数のように 広い範囲の数を柔軟に扱うことはできません。\nそれでも厳密に正しい値を保持したい 浮動小数点数では誤差を完全に避けることはできませんが\n計算結果が必ず真の値を含む範囲（区間）として得られる方法 があります。\nその一つが 区間演算（Interval Arithmetic） です。\n区間演算を用いることで、丸め誤差を含む計算でも、「真の値が必ずこの範囲にある」という 精度保証付きの計算(Verified numerics) が可能になります。\nまとめ コンピューターは有限のビット数しか持たないため、実数をそのまま格納することはできない IEEE 754 浮動小数点数は「近似計算のための仕組み」であり、誤差は避けられない 正確に表せる値はごく限られた「2進で有限に表せる数」のみ decimal 型や固定小数点数にも、精度や範囲の制限がある 「誤差を含んだまま安全に計算したい」という目的には区間演算が有効 次の記事では、区間演算ライブラリを紹介します。\n","permalink":"http://localhost:1313/posts/float/","summary":"\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e💡 \u003cstrong\u003eこの記事は「コンピューターで計算する」シリーズの一部です。\u003c/strong\u003e\u003cbr\u003e\n\u003ca href=\"../float\"\u003e\u003cstrong\u003e1. 浮動小数点数\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e👈 今ここ\u003c/strong\u003e\u003cbr\u003e\n\u003ca href=\"../interval\"\u003e\u003cstrong\u003e2. 区間演算\u003c/strong\u003e\u003c/a\u003e\u003cbr\u003e\n\u003ca href=\"../numericalIntegration\"\u003e\u003cstrong\u003e3. 数値積分\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003cp\u003eプログラミング中に \u003cstrong\u003e「0.1 + 0.2 が 0.3 にならない」\u003c/strong\u003e といった、浮動小数点数特有の挙動に戸惑った経験はないでしょうか。\u003cbr\u003e\nこれは、コンピューターが数を扱うときに広く使われている浮動小数点数が実数をそのまま正確に扱えないことに起因しています。\u003c/p\u003e","title":"浮動小数点数"}]